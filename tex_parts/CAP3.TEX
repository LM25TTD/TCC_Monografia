\chapter{Sistema de Seguran\c{c}a Veicular com uso de GPS}
\label{cap:prototipo do sistema}

Este capítulo apresenta a implementação do Sistema de Segurança Veicular com uso de GPS contemplando a criação do conceito, etapa de modelagem, elaboração do hardware embarcado no veículo, finalizando com o desenvolvimento da aplicação Web responsável pela lógica de negócio e interface com usuário.  

\section{Levantamento de requisitos}
Como ponto de partida é necessário definir o escopo do projeto partindo de uma idéia base, 
contendo os elementos interativos iniciais do sistema e sua representação conceitual. O cenário de operação
deste projeto é composto por alguns elementos que emitem e consomem informação:

\begin{itemize}
	\item Cada automóvel a ser verificado possui um módulo embarcado instalado e responsável por enviar sua 
	localização geográfica atual, esta informação é obtida por meio da tecnologia GPS. 
	\item  Os dados obtidos são enviados a um serviço Web. Após pesquisa de trabalho similares e soluções aplicadas,
	foi decidido pelo uso da rede GPRS de uma operadora de telefonia móvel.
  \item O serviço Web captura as informações e armazena em uma base de dados. 
	\item O usuário fará acesso ao sistema por meio de uma aplicação Web que oferece uma interface 
	de acesso às principais operações, como localizar o veículo sobre uma API de mapas e opcionalmente 
	realizar o desligamento remoto do mesmo. 
\end{itemize}

A Figura \ref{fig:visgeral} ilustra o modelo conceitual abstraído do sistema.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/1_conceitual.png}
\caption{Visão geral do sistema de seguran\c{c}a veicular com uso de GPS}
\label{fig:visgeral}
\end{figure}

\section{Especificação de Requisitos}
Seguindo as recomendações de \textcite{Wolf:2001} para projeto de sistemas embarcados, é necessário
capturar e descrever os requisitos. Nesta etapa, o Diagrama de Casos de Uso da UML foi utilizado, além disso a descrição dos casos permite o entendimento do fluxo de dados criando uma base
para descrição dos componentes para implementação.

\subsection{Casos de Uso}

Foram identificados dois atores do sistema: 

\begin{itemize}
	\item Ator "Usuário comum": Faz o uso final do sistema, realizando atividades como rastreamento e bloqueio
	de veículos.
	\item Ator "Administrador": Realiza operações de gerenciamento de usuário e módulos veiculares.
\end{itemize}
  
A figura \ref{fig:casosuso} ilustra o diagrama de casos de uso do projeto.

%\vspace{50pt}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/2_uc.png}
\caption{Casos de uso do sistema de seguran\c{c}a veicular com uso de GPS}
\label{fig:casosuso}
\end{figure}

\subsection{Descrição dos Casos de Uso}

Segundo \textcite{jacobson:2005}, podemos dizer que um caso de uso é um documento narrativo que descreve uma sequência de eventos de ator que usa um sistema para completar um processo, portanto, a descrição textual dos elementos da representação gráfica faz-se necessária.

As tabelas 3.1 e 3.2 descrevem os dois principais casos de uso do sistema, o restante das descrições encontra-se  em anexo no final deste documento.
\newpage
\begin{flushleft}
\tablefirsthead{}
\tablehead{}
\tabletail{}
\tablelasttail{}
\topcaption{Caso de Uso Obter Posi\c{c}\~{a}o Atual}
\begin{supertabular}{|m{5.5680003cm}|m{9.325cm}|}
\hline
Nome do caso de uso &
Obter posição atual\\\hline
Sumário &
Caso de uso que descreve a obtenção da posição atual de um veículo. \\\hline
Ator primário &
"Usuário comum"\\\hline
Atores secundários &
~
\\\hline
Precondições &
Usuário cadastrado e equipamentos associados a ele. \\\hline
Fluxo Principal &
1. Acessa página de rastreio.

2. Selecionar o veículo desejado.

3. O mapa é carregado na tela.

4. A posição atual é exibida no mapa, representada por um ponto especial.\\\hline
Fluxo Alternativo &
(2) Erro na comunicação com o equipamento

a. Em caso de falha na comunicação, o usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.

(3) Erro no servidor de mapas

a. O sistema deve informar o problema com os mapas, porém exibir os valores de longitude e latitude para que o usuário possa manualmente localizar o veículo.

(4) Acionar função tipo de visão.

a. Escolher entre visão de mapa ou visão de satélite.\\\hline
Pós-condições &
~
\\\hline
Requisitos não funcionais &
~\\\hline
Autor &
Leandro Bentes\\\hline
Data &
15/04/2013\\\hline
\end{supertabular}
\end{flushleft}

\newpage
\begin{flushleft}
\tablefirsthead{}
\tablehead{}
\tabletail{}
\tablelasttail{}
\topcaption{Configurar situa\c{c}\~{a}o de Bloqueio}
\begin{supertabular}{|m{5.5680003cm}|m{9.325cm}|}
\hline
Nome do caso de uso &
Setar Status de Bloqueio\\\hline
Sumário &
Este caso de uso descreve como o usuário realiza o bloqueio ou desbloqueio do veículo através do sistema com o objetivo de facilitar a recuperação do automóvel. \\\hline
Ator primário &
"Usuário comum"\\\hline
Atores secundários &
~
\\\hline
Precondições &
Usuário cadastrado e equipamentos associados a ele. Veículo cadastrado e equipamento configurado.\\\hline
Fluxo Principal &
1. Acessar página de rastreio.

2. Selecionar o veículo desejado.

3. Acionar botão bloquear.

4. O sistema exibe uma mensagem confirmando o bloqueio do veículo.\\\hline
Fluxo Alternativo &
(2) Erro na comunicação com o equipamento

a. Em caso de falha na comunicação, o usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.

(2) Desbloquear Veículo

a. Selecionar o botão de desbloqueio, que só estará disponível se houve um bloqueio anterior.

b. O sistema exibe uma mensagem confirmando o desbloqueio do veículo.

(5) Falha na ação

a. O usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.\\\hline
Pós-condições &
~\\\hline
Requisitos não funcionais &
~\\\hline
Autor &
Leandro Bentes\\\hline
Data &
15/04/2013\\\hline
\end{supertabular}
\end{flushleft}

\section{Modelo de classes para o módulo embarcado}

Para descrever os comportamentos de cada componente e integrá-los de forma lógica um Diagrama de Classes
é desenhado, uma vez que a orientação a objetos atende de forma completa a descrição do conjunto de hardware.
Pode-se abstrair comportamentos e representá-los através de métodos e abstrair estados como atributos de uma classe. 

A principal vantagem em modelar os componentes de hardware com o digrama de classes é observada
no momento de escrever funções ou bibliotecas para comunicação entre componentes, pois como o 
mapeamento de métodos necessários já está feito, o desenvolvimento é focado apenas nestes,
evitando a criação de código não utilizado. 

Para exemplificar esta situação, neste projeto o componente GSM fornece uma gama de funcionalidade 
que não são utilizadas, como funções de chamada de voz, mensagem SMS e outras,
porém como o modelo prevê apenas comportamentos relacionados a funções GPRS,
não foi despendido tempo com a implementação de serviços para acessar estas funcionalidades. 

A Figura \ref{fig:classemodveicular} ilustra o diagrama de classes UML que abstrai as funcionalidades do módulo veicular embarcado e 
o representa de forma estruturada lógica.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/5_mod_veicular.png}
\caption{Diagrama de Classes do Módulo Veicular}
\label{fig:classemodveicular}
\end{figure}

Conforme se observa no desenho de classes, o módulo se resume a quatro classes, em que existe uma composição na classe principal ModuloVeicularHw, isto significa que esta só existe juntamente com as outras da composição e se uma destas últimas for removida a principal deixará de existir. Ainda na classe principal são guardados os atributos de estado, conexão e posição atual, além de alguns atributos para verificação de erros.

A classe GSM possui como atributo principal uma lista de comandos AT, utilizados para acionar as diversas funções de celular, estes comandos são strings definidas pelo fabricante e descritas no manual do produto. Nota-se que apenas métodos relacionados com a função GPRS e conexões de rede dados foram mapeados, pois só existe a necessidade de uso nesta modalidade.

No modelo da classe GPS, os atributos principais utilizados para obter posição geográfica atual são latitude e longitude, porém para o funcionamento do hardware
dados de altitude, data, hora e número de satélites também são utilizados. Como comportamentos padrão existem: a obtenção da posição atual, velocidade, curso, satélites e data com hora.

O componente IO Veículo apenas representa as ações de bloquear, desbloquear e estado do alarme (não utilizado neste projeto). Como atributos, o estado do alarme e estado de bloqueio são representados.

\section{Arquitetura do Sistema}

Baseado no modelo conceitual, nos casos de uso, suas descrições e pesquisa de trabalhos correlatos,
é possível estabelecer um modelo arquitetural transcrito em um diagrama de componentes UML, 
seguindo recomendações estabelecidas para sistemas de tempo real de acordo com \textcite{Mendes:2002}.
Nesta etapa da modelagem são definidas algumas tecnologias utilizadas, uso de serviços externos e protocolos
de comunicação. A Figura \ref{fig:arquitetura} mostra o diagrama de componentes da UML gerado.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/4_arquitetural.png}
\caption{Diagrama de Arquitetura do Sistema de Seguran\c{c} Veicular com uso de GPS}
\label{fig:arquitetura}
\end{figure}


Pela definição arquitetural obteve-se um cenário onde existem dois componentes macro: o módulo veicular e o módulo Web chamado WebManager.

O módulo veicular pode ser dividido em diversos subcomponentes, interfaces requeridas e interfaces fornecidas conforme a descrições a seguir.

\begin{itemize}
	\item Serviço GPS: representa a utilização do serviço de rádio fornecido pelos satélites/estações GPS;
	\item Módulo GPS: hardware que implementa as funcionalidade GPS, se comunicando com o microcontrolador por um canal serial descrito como Serial GPS;
	\item Microcontrolador: componente físico que ATmega328 da placa Arduino;
	\item Digital I/O: Pinos digitais do microcontrolador que interagem com o I/O Veículo;
	\item I/O Veículo: Hardware que implementa o chaveamento para desligamento do veículo;
	\item Módulo GSM/GPRS: hardware que implementa funcionalidade de celular para acesso a rede GPRS. Se comunica com o microcontrolador por meio de um canal serial nomeado Serial GSM;
\end{itemize}

O módulo nomeado WebManager realiza o gerenciamento e aplicação das regras de negócio, interface com usuário e disponibilização do webservice. Seus principais componentes são:

\begin{itemize}
	\item REST API For Embedded: interface pela qual o módulo embarcado se comunica com o WebManager, é um webservice RESTful pronto para receber e responder às requisições dos módulos;
	\item Builder Sessão: gerenciador de sessões web necessário para dados transientes;
	\item Controller: componente que representa o conjunto de controllers (MVC) que atuam dentro do WebManager, manipulando requisições de módulos e usuários;
	\item IDao: Interfaces para acesso aos DAOs, os controllers possuem instâncias dessas interfaces para obter acesso ao banco;
	\item DAOs: Implementação dos DAOs que contém os scripts de consulta ao banco de dados;
	\item Banco de Dados: representação do conjunto de dados relacionais do WebManager armazenados;
	\item Controller API: Interface para os controllers por onde estes oferecem serviços a outros componentes;
	\item Security Framework: Componente responsável pela autenticação, autorização e controle de acesso ao sistema web. Utilizado para controle de perfis de usuários;
	\item UI Framework: Framework utilizado para implementação das views do sistema (páginas HTML);
	\item Maps API: Indica necessidade de acesso a um serviço de mapas de terceiros para representação visual no sistema.
\end{itemize}

\section{Hardware do módulo embarcado}

Conforme abordado no capítulo 2, a plataforma de prototipagem Arduino foi escolhida para servir de base para implementação em hardware do módulo embarcado, sendo que a placa controladora Arduino Uno é o núcleo funcional do mesmo. 

Baseado no modelo de classes da figura \ref{fig:classemodveicular}, é possível perceber que existe uma correspondência de um para um entre classe e hardware que implementa certa funcionalidade, assim sendo:

\begin{itemize}
	\item Classe ModuloVeicularHw: corresponde a placa controladora Arduino Uno.
	\item Classe GSM: corresponde em hardware ao Shield GSM que está acoplado a placa controladora.
	\item Classe GPS: corresponde ao Shield GPS com módulo GPS EM406 descrito no capítulo 2.
	\item IO Veículo: correspondente ao módulo de relé para acionamento de cargas em conjunto com um pino digital da placa controladora para realizar leitura do estado do alarme do veículo.
\end{itemize}

\subsection{Placa controladora}

O processo de montagem se inicia com a placa microcontroladora que recebe os shields conforme o desenvolvimento do firmware. A figura \ref{fig:arduinounoimpl} mostra o exemplar de Arduino Uno adquirido para montagem do protótipo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/arduinoUnoReal.jpg}
	\caption{Exemplar Arduino Uno}
	\label{fig:arduinounoimpl}
\end{figure}

Por serem parte de uma plataforma orientada a prototipagem, os hardwares da família Arduino possuem algumas características para facilitar a integração entre módulos, placas de circuito impresso e componentes de outra natureza, é possível enumerar as principais:

\begin{enumerate}
	\item Layout padrão: os shields seguem o mesmo desenho da placa controladora Arduino Uno, com isso não existe desproporcionalidade de tamanho na integração.
	\item Pinos para empilhamento: as placas possuem pinos passantes que permitem conectar nós de circuito a uma segunda placa empilhada sob a primeira. Os pinos são mostrados na figura \ref{fig:empilpin}.
	
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/stackPins.jpg}
	\caption{Pinos para empilhamento no Shield GSM}
	\label{fig:empilpin}
\end{figure}	

	\item O kit Arduino traz um conjunto de jumpers com terminais do tipo pino, facilmente conectáveis aos soquetes da placa controladora.
	\item Textos explicativos impressos sobre as placas descrevem a função de cada pino, diminuindo riscos de conexões erradas que podem levar à queima de componentes.
	
\end{enumerate}

\subsection{Shield GSM}

O próximo componente integrado é o Shield GSM, nesta etapa apenas é necessária a soldagem do pinos de empilhamento conforme a figura \ref{fig:empilpin}, e encaixar o conjunto sobre a placa controladora.

Conforme obtido na documentação disponibilizada pelo fabricante, este shield utiliza alimentação dos pinos 5V e 3.3V, além disso faz uso dos pino digitais 2 e 3 para abertura de um canal serial com o microcontrolador, o restante dos pinos fica livre para uso. Existe um conector para antena padrão SMA, que recebe uma antena quad band afim de melhorar a recepção de sinal da rede GSM. A figura \ref{fig:shieldgsmimpl} mostra a integração realizada.
 
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/arduinoAndGSM.jpg}
\caption{Shield GSM integrado ao Arduino Uno}
\label{fig:shieldgsmimpl}
\end{figure}

\newpage
\subsection{Shield GPS}

A próxima etapa é a integração do Shield GPS no conjunto atual, para isto se procede a soldagem dos pinos de empilhamento da mesma forma que no passo anterior, porém foi percebido na análise documental que existe um pequeno empecilho que demanda uma adaptação no hardware.

A questão é que o Shield GPS, assim como o GSM, também necessita de um canal serial com o microcontrolador. Em sua configuração padrão, este componente possui uma chave que permite alternar o canal serial entre os pares de pino 0-1 e 2-3, neste momento surge o problema:

\begin{itemize}
	\item Os pinos 0 e 1 formam o canal serial utilizado para programação e debug do microcontrolador via porta USB, portanto não é possível utilizá-lo nesta configuração.
	\item Os pinos 2 e 3 são utilizados pelo Shield GSM e não se pode compartilhar o mesmo canal.
\end{itemize}

A solução aplicada foi alterar os pinos do canal serial para o par 4-5 que se encontra livre. O desenho do shield permite fazer isto facilmente: conforme a figura \ref{fig:modgpsimpl}, existem dois pontos de solda no circuito com os textos "2" e "3", deve-se remover o pontos de solda desses locais e realizar um jumpeamento do ponto 2 para o pino 4 e do ponto 3 para o pino 5. A chave de seleção deve ser mantida na posição DLINE.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/gpsMod.jpg}
\caption{Modificação no Shield GPS}
\label{fig:modgpsimpl}
\end{figure}  

Após a modificação se procede o empilhamento da placa normalmente, deixando o conjunto com o aspecto da figura \ref{fig:empunogpsgsm}.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/arduinoGSMGPS.jpg}
\caption{Integração Arduino Uno, GSM e GPS}
\label{fig:empunogpsgsm}
\end{figure}

\subsection{Circuito de I/O com Veículo}

Um dos requisitos do sistema é a possibilidade de bloquear, ou seja, desligar o veículo e não permitir que o mesmo seja ligado novamente por meios normais. Após pesquisar sobre os métodos utilizados pelos alarmes automotivos para realizar este desligamento foi constatado que o mesmos comumente realizam uma intervenção sobre o circuito da bomba de combustível do veículo.

O funcionamento desta técnica se baseia no princípio de malhas fechadas, a figura \ref{fig:circbombnorm} representa o circuito de uma bomba de combustível automotiva: uma vez que a ignição fecha o circuito, a bomba fica alimentada e funciona normalmente.

 \begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/circBomba.png}
\caption{Circuito normal da bomba de combustível}
\label{fig:circbombnorm}
\end{figure}

A intervenção se dá na inserção de uma nova chave, neste caso um relé normalmente fechado\footnote{Um relé normalmente fechado permite a passagem de corrente entre dois pontos e, quando acionado, desconecta estes dois ponto impedindo a condução e abrindo o circuito.} é colocado em série com a chave de ignição, no momento que o microcontrolador acionar o relé, o circuito é aberto e a bomba deixa de funcionar por falta de alimentação. A figura \ref{fig:circbombinterv} mostra o circuito alterado e a chave representativa do relé se encontra aberta, indicando um bloqueio do veículo.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/circBombaFin.png}
\caption{Circuito da bomba após intervenção}
\label{fig:circbombinterv}
\end{figure}

A bomba de combustível de um automóvel possui uma corrente de operação de 5 a 6 ampéres, com pico de 10 ampéres, conforme relatado no capítulo 2, um microcontrolador necessita de um circuito externo, em geral feito com relés, para manipular esta carga. Para suprir esta necessidade foi adquirido um circuito com relé da fabricante Sparkfun. Detalhes deste componente se encontram no capítulo 2.

A integração deste circuito ao conjunto montado até o momento é feita por meio de três jumpers:

\begin{itemize}
	\item Jumper ligado em 5 V para alimentação da bobina do relé.
	\item Jumper ligado em GND (terra) também para a bobina;
  \intem Jumper de controle ligado no pino digital 12 para sinalizar o acionamento ou desligamento do relé.
\end{itemize}

Uma intervenção no circuito de relé foi necessária pois por padrão o conector da placa está interligado à malha normalmente aberta, com isso foram soldados dois cabos diretamente à malha normalmente fechada conforme a figura \ref{fig:fiosrelay}.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/jmpNC.jpg}
\caption{Fios interligados à malha normalmente fechada do relé}
\label{fig:fiosrelay}
\end{figure}

Ao final jumper também foi adicionado interligando o pino digital 9 ao pino RST para fins de reboot automático do microcontrolador quando necessário. A figura \ref{fig:modulomontado} mostra o conjunto completo montado.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/fullMount.jpg}
\caption{Conjunto de hardware do módulo embarcado montado}
\label{fig:modulomontado}
\end{figure}

\section {Desenvolvimento do Firmware}

O módulo embarcado possui um software de propósito específico, ou firmware, gravado na memória flash do microcontrolador, cujas principais funções são:

\begin{itemize}
	\item Comunicação e obtenção de dados GPS;
	\item Montagem do corpo da requisição ao webservice;
	\item Controle da conexão e transmissão de dados GPRS;
	\item Manipulação da resposta e tratamento de bloqueio/desbloqueio do veículo através do módulo de IO;
\end{itemize}

A criação desta rotina segue um modelo de atividades bem definidas, que se restringem a um laço de repetição principal. O modelo de programação da plataforma Arduino engloba a implementação de duas funções principais:

\begin{itemize}
	\item void setup(): função que é executada apenas uma vez a cada inicialização ou reboot da placa controladora, utilizada para inicialização de variáveis, configuração do modo dos pinos e bibliotecas.
	\item void loop(): bloco executado após o setup(), fazendo o que o próprio nome diz, um laço de repetição que executa enquanto o microcontrolador estiver ligado, permitindo a leitura e modificação de estado. Utilizado para realizar o controle efetivo da placa controladora.
\end{itemize} 

O passos fundamentais do firmware no módulo embarcado são descritas no diagrama de atividades da figura \ref{fig:sequencialogicabasica}, o fluxo principal se resume, após a execução da função setup (onde é aberta a conexão com o webservice), na repetição da obtenção dos dados GPS, envio dos dados ao servidor e leitura da resposta, verificando se deve se efetuar o bloqueio do veículo ou não.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/atividades_hl.png}
\caption{Sequência lógica do firmware}
\label{fig:sequencialogicabasica}
\end{figure}

Para realização das atividades que envolvem o uso dos shields e outros hardwares acoplados a placa controladora, é necessário criar uma interface de comunicação com os mesmos, que é feita na maioria dos casos, utilizando uma biblioteca fornecida pelo fabricante ou pela comunidade Arduino. Estas bibliotecas são conjuntos de rotinas escritas em C/C++ e integradas ao programa principal por meio de uma diretiva \emph{\#include<biblioteca.h>}.

As subseções a seguir descrevem a realização da interface com os shields GPS e GSM, além da comunicação com o módulo de IO (relé) e uso da funcionalidade EEPROM, que permite persistir um dado em memória não-volátil, recuperando seu estado em caso de reinicialização da placa.

\newpage
\subsection{Interface com EEPROM}

O microcontrolador da placa Arduino possui uma memória do tipo EEPROM: Electrically-Erasable Programmable Read-Only Memory, com tamanho de 1024 bytes no ATmega328. Neste tipo de memória os valores armazenados são mantidos mesmo que a placa seja desligada, atuando como um disco rígido para armazenamento não-volátil.

Este componente é essencial para realizar a persistência do estado de bloqueio do módulo embarcado, evitando que por um simples desligamento e religamento da bateria ocorra o desbloqueio do automóvel. A cada boot o último estado é restaurado e a cada alteração do mesmo, há uma atualização do valor na EEPROM.

A manipulação da EEPROM consiste na leitura e na escrita de dados, para ambos é necessário incluir o cabeçalho \#include<EEPROM.h>. 

A escrita de dados é feita pela função EEPROM.write(endereço, valor), onde endereço é um inteiro de 0 a 1023 e valor é um byte, aceitando valores de 0 a 255. Para leitura, a função EEPROM.read(endereço) é usada, bastando passar o valor do endereço como parâmetro e obter um byte como resposta.

O processo de leitura do último estado e de escrita do estado atual do módulo na memória EEPROM é mostrado no código \ref{code:eeprom}.

\renewcommand{\baselinestretch}{0.5}  % distância entre linhas
\begin{codigo}[htb]
\fontsize{9pt}{9pt}\selectfont
      \begin{boxit}  % coloca o código dentro de um Box
      \vspace{2mm}
      \VerbatimInput[xleftmargin=8mm,numbers=left,obeytabs=true]{sources/eeprom_write.cpp}
   \end{boxit}
   \caption{\it Rotinas de leitura e escrita em EEPROM}
   \label{code:eeprom}
\end{codigo}

\newpage

\subsection{Interface com I/O}

A interface com o módulo de I/O com relé é bastante simplificada, uma vez que sua integração é realizada por meio dos pinos digitais. O processo basicamente define que o pino de comunicação utilizado tenha seu modo de operação (entrada ou saída) definido na função setup, depois disso, basta realizar uma chamada da função digitalWrite(pino, estado), onde o parâmetro pino é o número do mesmo assim como descrito na impressão sobre o circuito impresso, e o parâmetro estado pode assumir o valor da macro HIGH (ligado) ou LOW (desligado). O código \ref{code:ctrlrelay} mostra a configuração e uso do pino de digital para acionamento ou desacionamento do relé de controle de carga.

\renewcommand{\baselinestretch}{0.5}  % distância entre linhas
\begin{codigo}[htb]
\fontsize{9pt}{9pt}\selectfont
      \begin{boxit}  % coloca o código dentro de um Box
      \vspace{2mm}
      \VerbatimInput[xleftmargin=8mm,numbers=left,obeytabs=true]{sources/io.cpp}
   \end{boxit}
   \caption{\it Rotinas de acionamento do pino digital para controle do relé}
   \label{code:ctrlrelay}
\end{codigo}
  

\subsection{Interface com Shield GPS}

O Shield GPS fornece está acoplado fisicamente à placa Arduino Uno e se comunicando por um canal serial estabelecido nos pinos 4 e 5 conforme abordado na seção 3.5.3, entretanto é preciso configurar este canal na inicialização do controlador e obter os dados enviados pelo módulo.

Para obtenção dos dados de posicionamento, dois artefatos necessitam estar presentes no código: 

\begin{itemize}
	\item Um canal serial lógico: feito utilizando a biblioteca SoftwareSerial, utilizado para efetuar a troca de dados bidirecional entre o microcontrolador e o módulo GPS.
	\item Um parser das mensagens GPRMC: a biblioteca TinyGPS disponibilizada pela comunidade realiza esta função, capturando as mesagens transmitidas pelo módulo e disponibilizando as informações 
\end{itemize}

Além de configurar os itens citados, é necessário que o módulo tenha completado a montagem da mensagem GPRMC (citada no capítulo 2), para isto é criada uma função auxiliar chamada feedGps() que faz uma checagem contínua no status da mensagem por meio de um laço de repetição, que é interrompido caso a mensagem esteja completa ou ocorra um timeout sem resposta.

O Código \ref{code:codegps} mostra as chamadas necessárias para capturar a posição atual do módulo GPS.

\renewcommand{\baselinestretch}{0.5}  % distância entre linhas
\begin{codigo}[htb]
\fontsize{9pt}{9pt}\selectfont
      \begin{boxit}  % coloca o código dentro de um Box
      \vspace{2mm}
      \VerbatimInput[xleftmargin=8mm,numbers=left,obeytabs=true]{sources/codegps.cpp}
   \end{boxit}
   \caption{\it Rotinas de obter a posição geográfica via GPS}
   \label{code:codegps}
\end{codigo}

\newpage
\subsection{Interface com Shield GSM}

O módulo SM5100B do Shield GSM não possui uma biblioteca do fabricante com funções pré-definidas para sua operação, mas é operável por meio de comandos AT especificados em suas referências porém uso direto de comandos AT insere duplicações no código fonte, eleva o consumo de memória, torna bastante complexo o controle de estados e a recuperação de erros.

No SDK Arduino existe uma biblioteca chamada SoftwareSerial com uma classe principal de mesmo nome, a qual abstrai os comportamentos de um elemento que se comunica com o microcontrolador por um canal serial, facilitando questões como a configuração de pinos RX e TX, transmissão e recepção serializada de dados, controle de buffer e outras questões pertinentes.

Foi implementada uma classe de comunicação com o módulo utilizando o conceito de herança do paradigma de orientação a objetos, onde a classe Shield GSM é uma subclasse de SoftwareSerial. 

A figura \ref{fig:classesm} mostra o diagrama da classe de comunicação e a herança de SoftwareSerial.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/lib_gsm.png}
	\caption{Classe de comunicação com SM5100B}
	\label{fig:classesm}
\end{figure}

\subsection{Requisição ao webservice}

O módulo veicular embarcado se comunica com o servidor web através de requisições HTTP POST, trazendo em seu
payload dados estruturados no padrão JSON. O adoção do método POST se deu pois o permite um maior tamanho de
mensagem, e como nesta mensagem são enviados dados autenticação, estes valores não seria gravados em texto
plano nos logs, como acontece com o GET. A estrutura JSON traz os seguintes campos:

\begin{itemize}
	\item idModule: código serial do módulo usado como identificador único na base de dados do sistema web.
	\item codAccess: usado como senha para validação da autenticidade do módulo.
	\item latitude: latitude geográfica atual obtida pelo GPS.
	\item longitude: longitude geográfica atual obtida pelo GPS.
	\item alarm: valor representando se o alarme do veículo foi acionado, 0 se falso 1 se verdadeiro. Não utilizado no momento.
\end{itemize}

A figura \ref{fig:requisicaohttp} mostra a mensagem enviada pelo módulo veicular a um servidor de testes, é possível observar o cabeçalho HTTP simulando um browser com engine Mozilla/5.0 e a sinalização do uso de dados estruturados JSON.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/requisicao_post.png}
	\caption{Requisição HTTP feita pelo módulo veicular}
	\label{fig:requisicaohttp}
\end{figure}

\subsection {Visão geral do funcionamento do módulo embarcado}

Conforme descrito anteriormente, o firmware opera em duas funções principais, a função void setup() e a função void loop(). A figura \ref{fig:seqsetup} mostra as atividades realizadas durante o boot, especificamente passos que envolvem a configuração para acesso a rede de dados GSM, login no APN da operadora, permitindo assim que seja realizada posteriormente a conexão e troca de dados com o webservice.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.5\textwidth]{figures/ModuloVeicular_Boot.png}
	\caption{Proceso de setup}
	\label{fig:seqsetup}
\end{figure}

\newpage
Na figura \ref{fig:seqloop} as atividades durante o loop envolvem a obtenção dos dados GPS, montagem da requisição, conexão e envio de dados ao webservice. Nos pontos onde existe possibilidade de falha há um direcionamento para a função de setup, onde qualquer configuração falha será substituída por novos valores, retomando o funcionamento normal.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.99\textwidth]{figures/ModuloVeicular_Loop.png}
	\caption{Atividades durante o loop}
	\label{fig:seqloop}
\end{figure}

\newpage

\section{Módulo Web (WebManager)}

O módulo web, definido também como WebManager, é a aplicação que roda na internet responsável por receber e armazenar os dados vindos do módulo embarcado, transmitir comandos para este e permitir a interação do usuário com o sistema. O WebManager conta com um webservice RESTful que é responsável pela comunicação com o módulo embarcado.

A técnica REST permite fazer mapeamentos de métodos diretamente em URL com correspondência aos métodos HTTP, um método de uma classe Java pode ser mapeado para uma URL chamada via método GET.

A implementação do WebManager como um todo foi feita utilizando a linguagem Java, por possuir um nível de maturidade muito alto para aplicações e serviços Web, contando com uma extensa gama de frameworks para os mais diversos fins, como mapeamento objeto-relacional, interface com o usuário,  webservices e outros.

Como banco de dados, o PostgreSQL foi adotado  pois possui um sofisticado mecanismo de bloqueio, suporta tamanhos ilimitados de linhas, bancos de dados e tabelas (até 16TB), aceita vários tipos de sub-consultas, possui mais tipos de dados e conta com um bom mecanismo de segurança contra falhas, por exemplo no desligamento repentino do sistema.

\subsection{Modelo geral}

A arquitetura da modelagem do WebManager foi baseada no padrão MVC que segundo \textcite{Mendes:2002} estabelece o desenvolvimento de software em camadas: classes de Entidade (Models), classes de controle (Control) e classes de interface com o usuário (View). 

O modelo MVC permite o desacoplamento das camadas de software facilitando a manutenção e diminuindo a repetição de código, as vantagens de sua utilização ficam bastante claras quando existe a necessidade da alteração de código, por exemplo, caso haja mudança nas regras de negócio de algum cálculo do sistema, apenas é necessária atualização do conteúdo da camada Control.

Além do modelo arquitetural base, alguns padrões de projeto como Singleton (utilizado no Security Framework), DAO, Factory Method descritos por \textcite{Gamma:2000}, foram aplicados pois o uso de padrões de projeto fornece soluções arquiteturais otimizadas para problemas conhecidos na engenharia de software. A Figura \ref{fig:classgeralwebman} mostra o diagrama de classes obtido.

\begin{landscape}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=20.00cm\textwidth]{figures/6_web_manager.png}
	\caption{Modelo de classes do WebManager}
	\label{fig:classgeralwebman}
\end{figure}
\end{landscape}

\subsection{Camada de modelo}

A camada de modelo representa os dados da aplicação e as regras do negócio que governam o acesso e a modificação dos dados. O modelo mantém o estado persistente do negócio e fornece ao controlador a capacidade de acessar as funcionalidades da aplicação encapsuladas pelo próprio modelo. As classes definidas nesta camada também são chamadas de entidades, o diagrama de classes para o modelo deste trabalho é mostrado na figura \ref{fig:webmanmodel}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/model.png}
	\caption{Model - Entidades do sistema}
	\label{fig:webmanmodel}
\end{figure}

Uma vez que o conceito define que esta camada guarda um estado persistido, o diagrama de classes gera naturalmente uma modelagem de banco de dados. A criação de uma base de dados relacional a partir deste modelo é facilitada com o uso de um framework de mapeamento objeto-relacional (object-relational mapping ou simplesmente ORM).

O framework Hibernate ORM foi adotado, adicionado alguns aspectos que facilitam o desenvolvimento de aplicações complexa, os principais são:

\begin{itemize}
	\item A base de dados é gerada automaticamente a partir das classes de modelo, eliminando o trabalho da criação de scripts DDL para criação de tabelas, chaves estrangeiras, constraints e outos aspectos inerentes à definição de banco de dados.
	\item A necessidade da criação de scripts SQL para consulta de dados é eliminada, pois se trabalha diretamente com objetos Java inter-relacionados. Ao se obter um atributo de um objeto, seja ele um atributo simples ou complexo, o framework gera em tempo de execução o script de consulta ao banco, abstraindo uniões, subconsultas e outras necessidades.
	\item O gerenciamento de transações é feita de maneira automatizada, bastando anotar os métodos transacionais para que haja este controle efetivo.
	\item Caso seja necessário criar consultas manuais, o Hibernate possui uma linguagem própria bastante intuitiva, chamada HQL, onde se trabalha facilmente com a combinação de atributos de classes para se obter informação desejada. 
\end{itemize}

O diagrama da figura \ref{fig:webmanmodel} foi traduzido em uma base de dados com seis tabelas, são elas:

\begin{enumerate}
	\item tb\_logposicao, que guarda a posição geográfica de cada requisição feita pelos módulos veiculares.
	\item tb\_moduloveicular, contém todos os módulos veiculares embarcados cadastrados no sistema.
	\item tb\_perfil, guardas os perfis de usuários do sistema, no caso administrador ou usuário comum.
	\item tb\_usuario, armazena todos os usuários cadastrados no sistema.
	\item tb\_perfilusuario, associa usuários e perfis.
	\item tb\_veiculo, contém todos os veículos cadastrados no sistema.
\end{enumerate}

\subsection{Camada de controle}

Nesta camada são definidos os controladores (controllers) do sistema, um controlador define o comportamento da aplicação, é ele que interpreta as ações do usuário e as mapeia para chamadas do modelo. Em um cliente de aplicações Web essas ações do usuário poderiam ser cliques de botões ou seleções de menus. As ações realizadas pelo modelo incluem ativar processos de negócio ou alterar o estado do modelo.

Na figura \ref{fig:webmancontrol} pode se observar que existe um controller para cada entidade principal do sistema, além de alguns métodos base para alteração do estado persistido do modelo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/webm_control.png}
	\caption{Controllers}
	\label{fig:webmancontrol}
\end{figure}

Os controladores são beans, componentes Java injetados na interface com o usuário permitindo acesso a serviços não apenas da camada de modelo, mas também serviços externos como no caso do Framework de mapas. Neste caso, o controlador ControllerVeiculo guarda uma instância de mapa que é atualizada conforme as informações do módulo veicular correspondente vão chegando, além disso o controlador atualiza a página web correspondente.

Nesta camada também é feita a integração com o Spring Security, framework que gerencia o Login, Logout e acesso aos serviços de acordo com o perfil do usuário, não permitindo que alguém logado com certo privilégio aceçe servi'so que não correspondem à sua credencial.

\newpage

\subsection {Webservice}

O webservice disponibilizado pela aplicação web é uma API RESTful, onde o serviço principal fica disponibilizado na URL \{servidor.url\}/AutoTrack\_WebManager/api/embedded. 

A figura \ref{fig:webmanwebservice} demonstra um exemplo de requisição e mapeamento feito pelo webservice para entidades manipuláveis na camada de controllers do sistema.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/RESTMapp.png}
	\caption{Esquema do webservice}
	\label{fig:webmanwebservice}
\end{figure}

O funcionamento do webservice pode ser sintetizado em alguns passos onde existe a interação entre o módulo veicular e a API REST, em concordância com a figura anterior as etapas são as seguintes: 

\begin{enumerate}
	\item O módulo embarcado monta uma requisição HTTP POST para a URL mostrada no esquema, esta requisição traz alguns parâmetros de configuração, como:
	\begin{itemize}
		\item Host: endereço de hospedagem da aplicação;
		\item Keep-alive: sinaliza que deverá mantera a conexão entre o módulo embarcado e o webservice sempre aberta.
		\item User-Agent: indica a engine do browser web, neste caso simula que a requisição está sendo feita de um navegador com engine Mozilla, como o Firefox.
		\item Accept e Content-Type: indica o tipo de conteúdo enviado e aceito como resposta, neste caso dados JSON.
		\item Content-Length: tamanho em bytes do campo payload.
		\item Payload: todo conteúdo compreendido entre as chaves, inclusive as mesmas, se trata de uma estrutura JSON trazendo informações sobre o módulo veicular embarcado utilizadas para alimentar o sistema. 
	\end{itemize}
	
	\item A requisição trafega sobre o protocolo HTTP, direcionado a URL em que o webservice está esperando. Esta URL está mapeada para uma função Java chamada addPosition() que recebe como parâmetro um objeto do tipo EmbeddedRequest. Este parâmetro é montado automaticamente pelo framework Spring a partir de um processo de parser da requisição, gerando um objeto EmbeddedRequest.
	\item Uma vez montado o objeto do tipo EmbeddedRequest, este é passado para a classe EmbeddedControl, responsável por montar recuperar do banco de dados as informações referentes ao módulo veicular que está enviando a requisição em questão e, de posse disto, gerar um nova entrada na tabela LogPosicao. A informação sobre o módulo veicular cruzada com o veículo de instalação mostra se existe ou não um bloqueio do conjunto.
	\item De acordo com o estado de bloqueio, a resposta para o módulo veicular é diferente: caso exista um bloqueio, o webservice responde com status HTTP 200, caso contrário ele responderá com status HTTP 300.
	\item O módulo veicular analisa o status de resposta e age caso necessário.
\end{enumerate}


\subsection{DAO}

Conforme descrito no capítulo 2, Data Accs Object é um padrão de projeto que separa as regras de acesso ao banco de dados em uma nova camada. Neste trabalho a camada DAO implementa algumas classes que contém métodos definidos no framework Hibernate para operações CRUD, conforme a figura \ref{fig:webmandao}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/dao_layer.png}
	\caption{Camada DAO}
	\label{fig:webmandao}
\end{figure}

O par de interface/classe respectivamente IGenericDAO/GenericDao, contém métodos para operações CRUD anotados com as respectivas configurações de transação. Os principais métodos da implementação genérica são:

\begin{itemize}
	\item save(object): Salva um objeto de uma classe definida como entidade no banco de dados.
	\item delete(object): Remove do banco de dados o objeto passado como parâmetro.
	\item update(object): Atualiza os atributos de um objeto previamente salvo no banco de dados.
	\item getAll(class): Retorna uma lista contendo todos os objetos do tipo da classe passada como parâmetro que estejam salvos no banco de dados.
\end{itemize}

As classes especializadas VeiculoDAO, ModuloVeicularDAO e UsuarioDAO, além de suas respectivas interfaces, apenas estendem a implementação genérica com a inclusão de métodos de busca específicos, utilizados para alguns cenários.

Cada controller contém como atributo uma interface para o DAOs correspondente a sua natureza, que sofre injeção de uma instância da classe correlata em tempo de execução. O uso de interface permite que, durante um teste unitário, a implementação real seja substituída por um mock, isolado a classe a ser testada de dependências externas.

\subsection{View}

Para implementação da camada de view, que neste escopo são páginas Web, foi utilizado o framework Primefaces, que fornece uma infinidade de componentes de UI prontos para uso, bastando setar algumas propriedades. As páginas são escritas em XHTML e interpretadas por um container como o Tomcat, que fornece o ambiente de execução para aplicações Java Web.

O funcionamento do módulo web é bastante simples, um usuário acessa o sistema por meio de um login e senha fornecidos, em caso de sucesso é direcionado à página de rastreamento onde pode efetuar a seleção do veículo pertencente a ele a fim de realizar o rastreamento. A figura \ref{fig:webmanviewlogin} mostra a tela de login do sistema.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/webmanager_login.png}
	\caption{Tela de Login do Sistema}
	\label{fig:webmanviewlogin}
\end{figure}

O rastreamento do módulo é feito com o auxílio da API do Google Maps. O framework Primefaces possui um componente que realiza esta lainkgem com a API, trazendo os dados geográficos correspondente a uma posição latitude-longitude fornecida.

A figura \ref{fig:webmanviewrastrear} exibe a página de rastreamento de veículo, é possível perceber o círculo verde que corresponde a posição aproximada do veículo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/webmanager_rastrear.png}
	\caption{Tela de Rastreamento}
	\label{fig:webmanviewrastrear}
\end{figure}

A ação de bloqueio do veículo é realizada por meio do botão "Bloquear", que atualiza o estado do veículo em foco no banco de dados. Com isto, ao realizar a próxima requisição ao webservice, o módulo embarcado no veículo citado reberá uma resposta HTTP correspondente à ação de bloqueio e assim deverá acionar o mecanismo para realizar a ação.

\hfill


\chapter{Desenvolvimento do Protótipo}
\label{cap:desenvolvimento do prototipo}

\section{Modelo Conceitual}
Como ponto de partida é necessário definir o escopo do projeto partindo de uma idéia base, 
contendo os elementos interativos iniciais do sistema e sua representação conceitual. O cenário de operação
deste trabalho é composto por alguns elementos que emitem e consomem informação:

\begin{itemize}
	\item Cada automóvel a ser verificado possui um módulo embarcado instalado e responsável por enviar sua 
	localização geográfica atual, esta informação é obtida por meio da tecnologia GPS. 
	\item  Os dados obtidos dados são enviados a um serviço Web. Após pesquisa de trabalho similares e soluções aplicadas,
	foi decidido pelo uso da rede GPRS de uma operadora de telefonia móvel.
  \item O serviço Web captura as informações e organiza em uma base de dados. 
	\item O usuário fará acesso ao sistema por meio de uma aplicação Web que oferece uma interface 
	de acesso às principais operações, como localizar seus veículos sobre uma API de mapas e opcionalmente 
	realizar o desligamento remoto dos mesmos. 
\end{itemize}

A Figura 3.1 mostra o modelo conceitual abstraído do sistema.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/1_conceitual.png}
\caption{Visão conceitual do sistema}
\label{1}
\end{figure}

\section{Especificação de Requisitos}
Seguindo as recomendações de \textcite{Wolf:2001} para projeto de sistemas embarcados, é necessário
capturar e descrever os requisitos, para realizar esta etapa, o Diagrama de Casos de Uso da UML se
mostra ideal, além disso a descrição dos casos permite o entendimento do fluxo de dados criando uma base
para descrição dos componentes para implementação.

\subsection{Casos de Uso}

Foram identificados dois atores do sistema (agentes externos): 

\begin{itemize}
	\item Ator "Usuário comum": Faz o uso final do sistema, realizando atividades como rastreamento e bloqueio
	de veículos.
	\item Ator "Administrador": Realiza operações de gerenciamento de usuário e módulos veiculares.
\end{itemize}
  
A figura 3.2 retrata os casos de uso de cada ator identificado.

%\vspace{50pt}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/2_uc.png}
\caption{Casos de uso do sistema}
\label{1}
\end{figure}

\subsection{Descrição dos Casos de Uso}

Segundo \textcite{jacobson:2005}, podemos dizer que um caso de uso é um documento narrativo que descreve uma sequência de eventos de ator que usa um sistema para completar um processo, portanto, a descrição textual dos elementos da representação gráfica se faz necessária.

As tabelas 3.1 e 3.2 descrevem os dois principais casos de uso do sistema, o restante das descrições se encontra nos anexos.

\begin{flushleft}
\tablefirsthead{}
\tablehead{}
\tabletail{}
\tablelasttail{}
\bottomcaption{Caso de Uso Obter Posi\c{c}\~{a}o Atual}
\begin{supertabular}{|m{5.5680003cm}|m{9.325cm}|}
\hline
Nome do caso de uso &
Obter posição atual\\\hline
Sumário &
Caso que descreve a obtenção da posição atual de um veículo. \\\hline
Ator primário &
Usuário\\\hline
Atores secundários &
~
\\\hline
Precondições &
Usuário cadastrado e equipamentos associados a ele. \\\hline
Fluxo Principal &
1. Acessa página de rastreio.

2. Selecionar o veículo desejado.

3. O mapa é carregado na tela.

4. A posição atual é exibida no mapa, representada por um ponto especial.\\\hline
Fluxo Alternativo &
(2) Erro na comunicação com o equipamento

a. Em caso de falha na comunicação, o usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.

(3) Erro no servidor de mapas

a. O sistema deve informar o problema com os mapas, porém exibir os valores de longitude e latitude para que o usuário possa manualmente localizar o veículo.

(4) Acionar função tipo de visão.

a. Escolher entre visão de mapa ou visão de satélite.\\\hline
Pós-condições &
~
\\\hline
Requisitos não funcionais &
~\\\hline
Autor &
Leandro Bentes\\\hline
Data &
15/04/2013\\\hline
\end{supertabular}
\end{flushleft}

\begin{flushleft}
\tablefirsthead{}
\tablehead{}
\tabletail{}
\tablelasttail{}
\bottomcaption{Caso de Uso Setar Status de Bloqueio}
\begin{supertabular}{|m{5.5680003cm}|m{9.325cm}|}
\hline
Nome do caso de uso &
Setar Status de Bloqueio\\\hline
Sumário &
Este caso descreve como o usuário realiza o bloqueio ou desbloqueio do veículo através do sistema com o objetivo de facilitar a recuperação do automóvel. \\\hline
Ator primário &
Usuário\\\hline
Atores secundários &
~
\\\hline
Precondições &
Usuário cadastrado e equipamentos associados a ele. Veículo cadastrado e equipamento configurado.\\\hline
Fluxo Principal &
1. Acessar página de rastreio.

2. Selecionar o veículo desejado.

3. Acionar botão bloquear.

4. O sistema exibe uma mensagem confirmando o bloqueio do veículo.\\\hline
Fluxo Alternativo &
(2) Erro na comunicação com o equipamento

a. Em caso de falha na comunicação, o usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.

(2) Desbloquear Veículo

a. Selecionar o botão de desbloqueio, que só estará disponível se houve um bloqueio anterior.

b. O sistema exibe uma mensagem confirmando o desbloqueio do veículo.

(5) Falha na ação

a. O usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.\\\hline
Pós-condições &
~\\\hline
Requisitos não funcionais &
~\\\hline
Autor &
Leandro Bentes\\\hline
Data &
15/04/2013\\\hline
\end{supertabular}
\end{flushleft}

\section{Arquitetura do Sistema}

Baseado no modelo conceitual, nos casos de uso, suas descrições e pesquisa de trabalhos correlatos,
é possível estabelecer um modelo arquitetural transcrito em um diagrama de componentes UML, 
seguindo recomendações estabelecidas para sistemas de tempo real de acordo com \textcite{Mendes:2002}.
Nesta etapa da modelagem são definidas algumas tecnologias utilizadas, uso de serviços externos e protocolos
de comunicação. A Figura 3.3 mostra o diagrama de componentes da UML gerado.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/4_arquitetural.png}
\caption{Arquitetura do Sistema}
\label{Figura 3}
\end{figure}


Pela definição arquitetural obteve-se um cenário onde existem dois componentes macro: o módulo veicular e o módulo Web chamado WebManager.

O módulo veicular pode ser destrinchado em diversos subcomponentes, interfaces requeridas e interfaces fornecidas conforme a descrições a seguir.

\begin{itemize}
	\item Serviço GPS: representa a utilização do serviço de rádio fornecido pelos satélites/estações GPS;
	\item Módulo GPS: hardware que implementa as funcionalidade GPS, se comunicando com o microcontrolador por um canal serial descrito como Serial GPS;
	\item MicroControlador: componente físico que ATmega328 da placa Arduino;
	\item Digital I/O: Pinos digitais do microcontrolador que interagem com o I/O Veículo;
	\item I/O Veículo: Hardware que implementa o chaveamento para desligamento do veículo;
	\item Módulo GSM/GPRS: hardware que implementa funcionalidade de celular para acesso a rede GPRS. Se comunica com o microcontrolador por meio de um canal serial nomeado Serial GSM;
\end{itemize}

O módulo nomeado WebManager realiza o gerenciamento e aplicação das regras de negócio, interface com usuário e diponibilização do webservice. Seus principais componentes são:

\begin{itemize}
	\item REST API For Embedded: interface pela qual o módulo embarcado se comunica com o WebManager, é um webservice RESTful pronto para receber e responder às requisições dos módulos;
	\item Builder Sessão: gerenciador de sessões web necessário para dados transientes;
	\item Controller: componente que representa o conjunto de controllers (MVC) que atuam dentro do WebManager, manipulando requisições de módulos e usuários;
	\item IDao: Interfaces para acesso aos DAOs, os controllers possuem instâncias dessas interfaces para obter acesso ao banco;
	\item DAOs: Implementação dos DAOs que contém os scripts de consulta ao banco de dados;
	\item Banco de Dados: representação do conjunto de dados relacionais do WebManager armazenados;
	\item Controller API: Interface para os controllers por onde estes oferecem serviços a outros componentes;
	\item Security Framework: Componente responsável pela autenticação, autorização e controle de acesso ao sistema web. Utilizado para controle de perfis de usuários;
	\item UI Framework: Framework utilizado para implementação das views do sistema (páginas HTML);
	\item Maps API: Indica necessidade de acesso a um serviço de mapas de terceiros para representação visual no sistema.
\end{itemize}

\section{Modelo de classes para o módulo embarcado}

Para descrever os comportamentos de cada componente e integrá-los de forma lógica um Diagrama de Classes
é desenhado, uma vez que a orientação a objetos atende de forma completa a descrição do conjunto de hardware.
Pode-se abstrair comportamentos e representá-los através de métodos e abstrair estados como atributos de uma classe. 

A principal vantagem em modelar os componentes de hardware com o digrama de classes é observada
no momento de escrever funções ou bibliotecas para comunicação entre componentes, pois como o 
mapeamento de métodos necessários já está feito, o desenvolvimento é focado apenas nestes,
evitando a criação de código não utilizado. 

Para exemplificar esta situação, neste projeto o componente GSM fornece uma gama de funcionalidade 
que não são utilizadas, como funções de chamada de voz, mensagem SMS e outras,
porém como o modelo prevê apenas comportamentos relacionados a funções GPRS,
não foi despendido tempo com a implementação de serviços para acessar estas funcionalidades. 

A Figura 3.4 mostra o diagrama de classes UML que abstrai as funcionalidades do módulo veicular embarcado e 
o representa de forma estruturada lógica.

\newpage

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/5_mod_veicular.png}
\caption{Diagrama de Classes do Módulo Veicular}
\label{1}
\end{figure}

\section{Módulo Veicular Embarcado - Hardware}
Após a análise do diagrama de classes, foram identificados os componentes de hardware,
são estes:
\begin{itemize}
	\item Módulo GPS.
	\item Módulo GSM.
	\item Módulo de I/O.
\end{itemize}
Para implementação em hardware foi escolhida a plataforma Arduino, pois
traz a filosofia do hardware open-source com seus diagramas disponíveis 
livremente na Internet e uma comunidade ativa no desenvolvimento de soluções.

Como placa microcontroladora, o Arduino Uno foi selecionado, pois oferece
poder de processamento suficiente para o projeto, preço acessível e dimensões
físicas propícias para integração veicular. A placa traz um microcontrolador
Atmega 328 da Atmel, que possui 32 kbytes de memória flash, 2 kbytes de memória
RAM, pinos de I/O digital e analógicos, comunicação serial e opera a um clock de
16 MHz. A figura 5 mostra um exemplar da placa Arduino Uno.

\begin{figure}[!htb]
\centering
\includegraphics[width=3.00cm\textwidth]{figures/arduinoUno.jpg}
\caption{Placa Arduino Uno}
\label{Figura 5}
\end{figure}

A plataforma Arduino oferece diversos módulos de hardware plugáveis
para as mais diversas funções, que são chamados de Shields. Estes módulos
objetivam ser plug-and-play, ou seja, procuram poupar o máximo o trabalho
de soldagem e aplicação de componentes discretos.

Para função de hardware GPS, o Shield GPS Sparkfun foi escolhido, este shield
traz um módulo GPS EM 406 com precisão de 5 metros na medida de posição, comunicável
por interface serial RS 232 ou TTL. A figura 6 mostra o shield GPS juntamente com o 
módulo GPS EM 406.

\begin{figure}[!htb]
\centering
\includegraphics[width=7.00cm\textwidth]{figures/6_gps.png}
\caption{GPS Shield e Módulo EM 406}
\label{Figura 6}
\end{figure}

Para comunicação com o servidor, se fez necessária uma alternativa que utilizasse
envio de dados sobre a rede de celular, pois esta rede possui altíssima cobertura
em área urbana, foco do projeto. A troca de dados se dá sobre o protocolo GPRS, que
especifica um máximo de 80 kbps para download e 20 kpbs para upload de dados.

Uma das soluções em shield para Arduino é o Cellular Shield Sparkfun, que traz um
módulo SendTrue SM5100B como interface com a rede. As especificações do módulo incluem:

\begin{itemize}
			\item Quad-Band 850/900/1800/1900 MHz
			\item Controle via comandos AT
			\item Alimentação: 3,2 a 4,2V
			\item Baixo consumo: 350,0mA (\textit{consumo médio em transmissão})
			\item Temperatura de operação: -10 a 85 graus Celsius.
\end{itemize}

A figura 7 mostra o Cellular Shield Sparkfun com módulo SM5100B que foi aplicado
no projeto. O shield foi utilizado com antena quad-band que não está contemplada
na figura.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=4.00cm\textwidth]{figures/gsm.jpg}
	\caption{Cellular Shield com SM5100B}
	\label{Figura 7}
\end{figure}

O módulo SM5100B não possui uma biblioteca do fabricante com funções pré-definidas para sua 
operação, mas é operável por meio de comandos AT especificados em suas referências. Entretanto,
o uso direto de comandos AT insere duplicações no código fonte, eleva o consumo de memória,
torna bastante complexo o controle de estados e a recuperação de erros. Para contornar esta questão,
foi implementada uma classe de comunicação com o módulo, que é uma subclasse de SoftwareSerial, que por
sua vez é uma classe de comunicação serial RS 232 com controle via software. A figura 8 mostra o diagrama
da classe de comunicação e a herança de SoftwareSerial.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=9.00cm\textwidth]{figures/lib_gsm.png}
	\caption{Classe de comunicação com SM5100B}
	\label{Figura 8}
\end{figure}

Um dos requisitos funcionais do projeto prevê o bloqueio remoto de um veículo por meio do desligamento 
do motor. Após um estudo dos circuitos elétricos veiculares e pesquisa sobre métodos de bloqueio mais
utilizados, chgou-se à conclusão que a melhor alternativa é a interrupção da alimentação elétrica
da bomba de cmbustível, esta estratégia é utilizada pelos módulos de alarme mais confiáveis do mercado
para implementar o desligamento do veículo.

Como a bomba de combustível opera em um circuito que gera corrente entre 5 e 10 ampéres, foi preciso
utilizar um componente que trabalhe com esta faixa de carga. Um relê foi a solução aplicada, mais epecificamente
o circuito normalmente fechado do relê, cuja carga suportada é de 10 A. Para acionamento do relê, um circuito
auxiliar que utiliza o sinal de uma das saídas digitais do Arduino Uno foi usado, assim, o sinal de baixa corrente
da porta digital controla o acionamento da bobina de um relê, que aciona mecanicamente o circuito normalmente fechado
ligado a bomba de combustível, interrompendo a alimentação da mesma quando solicitado. A figura 9 mostra o módulo de
I/O com relê integrado.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=5.00cm\textwidth]{figures/beefcake2.jpg}
	\caption{Módulo de I/O com veículo}
	\label{Figura 9}
\end{figure}

Após a seleção dos componentes, o módulo veicular foi montado. Os shields foram montados com facilidade já que
existe uma conexão física padrão, apenas alguns ajustes foram necessários: no módulo GPS, os pinos de comunicação
serial (TX e RX) coincidiram com os pinos do módulo GSM (pinos 2 e 3 digital da placa Aduino), para solucionar
a questão, um jumper foi feito de modo a conectar a transmissão e recepção do GPS nos pinos 4 e 5 da placa Arduino.
A figura 10 mostra o módulo embarcado montado.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=5.00cm\textwidth]{figures/prototipo_4.jpg}
	\caption{Módulo veicular montado}
	\label{Figura 10}
\end{figure}

O módulo veicular embarcado se comunica com o servidor web através de requisições HTTP POST, trazendo em seu
payload dados estruturados no padrão JSON. O adoção do método POST se deu pois o permite um maior tamanho de
mensagem, e como nesta mensagem são enviados dados autenticação, estes valores não seria gravados em texto
plano nos logs, como acontece com o GET. A estrutura JSON traz os seguintes campos:

\begin{itemize}
	\item idModule: código serial do módulo usado como identificador único na base de dados do sistema web.
	\item codAccess: usado como senha para validação da autenticidade do módulo.
	\item latitude: latitude geográfica atual obtida pelo GPS.
	\item longitude: longitude geográfica atual obtida pelo GPS.
	\item alarm: valor representando se o alarme do veículo foi acionado, 0 se falso 1 se verdadeiro. Não utilizado no momento.
\end{itemize}

A figura 11 mostra a mensagem enviada pelo módulo veicular a um servidor de testes, é possível observer o cabeçalho HTTP simulando um browser com engine Mozilla/5.0 e a sinalização do uso de dados estruturados JSON.


\begin{figure}[!htb]
	\centering
	\includegraphics[width=7.00cm\textwidth]{figures/requisicao_post.png}
	\caption{Requisição HTTP feita pelo módulo veicular}
	\label{Figura 11}
\end{figure}

\section{Módulo Web (WebManager) - Introdução}

O módulo web, ou WebManager, é a aplicação que roda na internet responsável por receber e armezenar os dados vindos do módulo embarcado, transmitir comandos para este e permitir a interação do usuário com o sistema. O WebManager conta com um webservice RESTful que é responsável pela comunicação com o módulo embarcado.

Um webservice é uma solução adotada na integração de sistemas que funcionam em diferentes arquiteturas de hardware, normalizando a troca de informações para um formato (linguagem) universal, em geral uma combinação de uso do protocolo HTTP e dados estruturados XML/JSON. 

A técnica REST permite fazer mapeamentos de métodos diretamente em URL com correspondência aos métodos HTTP, por exemplo, uma método de uma classe Java pode ser mapeado para uma URL chamada via método GET.

A implementação do WebManager como um todo foi feita utilizando a linguagem Java, por possuir um nível de maturidade muito alto para aplicações e serviços Web, contando com uma extensa gama de frameworks para os mais diversos fins, como mapeamento objeto-relacional, interface com o usuário,  webservices e outros.

Como banco de dados, o PostgreSQL foi adotado  pois possui um sofisticado mecanismo de bloqueio, suporta tamanhos ilimitados de linhas, bancos de dados e tabelas (até 16TB), aceita vários tipos de sub-consultas, possui mais tipos de dados e conta com um bom mecanismo de FAILSAVE (Segurança contra falhas, por exemplo no desligamento repentino do sistema).

\section{Módulo Web (WebManager) - Modelagem}

A arquitetura da modelagam do WebManager foi baseada no Pattern MVC que segundo \textcite{Mendes:2002} estabelece o desenvolvimento de software em camadas: classes de Entidade (Models), classes de controle (Control) e classes de interface com o usuário (View). 

O modelo MVC é consagrado, pois permite o desacoplamento das camadas de software facilitando a manutenção e diminuindo a repetição de código, as vantagens de sua utilização ficam bastante claras quando existe a necessidade da alteração de código, por exemplo, caso haja mudança nas regras de negócio de algum cálculo do sistema, apenas é necessária atualização do conteúdo da camada Control. Além do modelo arquitetural base, alguns padrões de projeto como Singleton (utilizado no Security Framework e DAO's) e Facade (agregando funções de diversas interfaces a uma interface centralizada que é exposta para os subsistemas), descritos por \textcite{Gamma:2000}, foram aplicados pois o uso de padrões de projeto fornece soluções arquiteturais otimizadas para problemas conhecidos na engenharia de software. A Figura 12 mostra o diagrama de classes obtido.

\begin{landscape}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=20.00cm\textwidth]{figures/6_web_manager.png}
	\caption{Modelo de classes do WebManager}
	\label{Figura 12}
\end{figure}
\end{landscape}

\section{Módulo Web (WebManager) - Desenvolvimento}
A implementação em do código do WebManager contemplou primeiramente o webservice e as camadas de model e controllers, deixando a implementação da interface com o usuário como última etapa. A modelagem de banco de dados utilizando modelo entidade-relacionamento não foi necessária, uma vez que a camada Model contendo as entidades do sistema sofreu um mapeamento objeto-realcional (ORM) feito pelo framework Hibernate. Este mapeamento isenta o desenvolvedor de criar na maioria dos casos, cláusulas SQL, deixando-o apenas com o trabalho de manipular instâncias de classes e seus atributos. A camada de entidades é mostrada na figura 13.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/model.png}
	\caption{Model - Entidades do sistema}
	\label{Figura 13}
\end{figure}

O funcionamento do módulo web é bastante simples, um usuário acessa o sistema por meio de um login e senha fornecidos, em caso de sucesso é direcionado à página de rastreamento onde pode efetuar a seleção do veículo pertencente a ele a fim de ralizar o rastreamento, ação esta que é exibida em um mapa da API Google Maps. A figura 14 mostra a tela de login do sistema e a figura 15 exibe a tela de rastreamento principal.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/webmanager_login.png}
	\caption{Tela de Login do Sistema}
	\label{Figura 14}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/webmanager_rastrear.png}
	\caption{Tela de Rastreamento}
	\label{Figura 15}
\end{figure}

\hfill


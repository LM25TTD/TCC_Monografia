\chapter{Desenvolvimento do Protótipo}
\label{cap:desenvolvimento do prototipo}

\section{Modelo Conceitual}
Como ponto de partida é necessário definir o escopo do projeto partindo de uma idéia base, 
contendo os elementos interativos iniciais do sistema e sua representação conceitual. O cenário de operação
deste trabalho é composto por alguns elementos que emitem e consomem informação:

\begin{itemize}
	\item Cada automóvel a ser verificado possui um módulo embarcado instalado e responsável por enviar sua 
	localização geográfica atual, esta informação é obtida por meio da tecnologia GPS. 
	\item  Os dados obtidos dados são enviados a um serviço Web. Após pesquisa de trabalho similares e soluções aplicadas,
	foi decidido pelo uso da rede GPRS de uma operadora de telefonia móvel.
  \item O serviço Web captura as informações e organiza em uma base de dados. 
	\item O usuário fará acesso ao sistema por meio de uma aplicação Web que oferece uma interface 
	de acesso às principais operações, como localizar seus veículos sobre uma API de mapas e opcionalmente 
	realizar o desligamento remoto dos mesmos. 
\end{itemize}

A Figura 3.1 mostra o modelo conceitual abstraído do sistema.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/1_conceitual.png}
\caption{Visão conceitual do sistema}
\label{1}
\end{figure}

\section{Especificação de Requisitos}
Seguindo as recomendações de \textcite{Wolf:2001} para projeto de sistemas embarcados, é necessário
capturar e descrever os requisitos, para realizar esta etapa, o Diagrama de Casos de Uso da UML se
mostra ideal, além disso a descrição dos casos permite o entendimento do fluxo de dados criando uma base
para descrição dos componentes para implementação.

\subsection{Casos de Uso}

Foram identificados dois atores do sistema (agentes externos): 

\begin{itemize}
	\item Ator "Usuário comum": Faz o uso final do sistema, realizando atividades como rastreamento e bloqueio
	de veículos.
	\item Ator "Administrador": Realiza operações de gerenciamento de usuário e módulos veiculares.
\end{itemize}
  
A figura 3.2 retrata os casos de uso de cada ator identificado.

%\vspace{50pt}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/2_uc.png}
\caption{Casos de uso do sistema}
\label{1}
\end{figure}

\subsection{Descrição dos Casos de Uso}

Segundo \textcite{jacobson:2005}, podemos dizer que um caso de uso é um documento narrativo que descreve uma sequência de eventos de ator que usa um sistema para completar um processo, portanto, a descrição textual dos elementos da representação gráfica se faz necessária.

As tabelas 3.1 e 3.2 descrevem os dois principais casos de uso do sistema, o restante das descrições se encontra nos anexos.

\begin{flushleft}
\tablefirsthead{}
\tablehead{}
\tabletail{}
\tablelasttail{}
\bottomcaption{Caso de Uso Obter Posi\c{c}\~{a}o Atual}
\begin{supertabular}{|m{5.5680003cm}|m{9.325cm}|}
\hline
Nome do caso de uso &
Obter posição atual\\\hline
Sumário &
Caso que descreve a obtenção da posição atual de um veículo. \\\hline
Ator primário &
Usuário\\\hline
Atores secundários &
~
\\\hline
Precondições &
Usuário cadastrado e equipamentos associados a ele. \\\hline
Fluxo Principal &
1. Acessa página de rastreio.

2. Selecionar o veículo desejado.

3. O mapa é carregado na tela.

4. A posição atual é exibida no mapa, representada por um ponto especial.\\\hline
Fluxo Alternativo &
(2) Erro na comunicação com o equipamento

a. Em caso de falha na comunicação, o usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.

(3) Erro no servidor de mapas

a. O sistema deve informar o problema com os mapas, porém exibir os valores de longitude e latitude para que o usuário possa manualmente localizar o veículo.

(4) Acionar função tipo de visão.

a. Escolher entre visão de mapa ou visão de satélite.\\\hline
Pós-condições &
~
\\\hline
Requisitos não funcionais &
~\\\hline
Autor &
Leandro Bentes\\\hline
Data &
15/04/2013\\\hline
\end{supertabular}
\end{flushleft}

\begin{flushleft}
\tablefirsthead{}
\tablehead{}
\tabletail{}
\tablelasttail{}
\bottomcaption{Caso de Uso Setar Status de Bloqueio}
\begin{supertabular}{|m{5.5680003cm}|m{9.325cm}|}
\hline
Nome do caso de uso &
Setar Status de Bloqueio\\\hline
Sumário &
Este caso descreve como o usuário realiza o bloqueio ou desbloqueio do veículo através do sistema com o objetivo de facilitar a recuperação do automóvel. \\\hline
Ator primário &
Usuário\\\hline
Atores secundários &
~
\\\hline
Precondições &
Usuário cadastrado e equipamentos associados a ele. Veículo cadastrado e equipamento configurado.\\\hline
Fluxo Principal &
1. Acessar página de rastreio.

2. Selecionar o veículo desejado.

3. Acionar botão bloquear.

4. O sistema exibe uma mensagem confirmando o bloqueio do veículo.\\\hline
Fluxo Alternativo &
(2) Erro na comunicação com o equipamento

a. Em caso de falha na comunicação, o usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.

(2) Desbloquear Veículo

a. Selecionar o botão de desbloqueio, que só estará disponível se houve um bloqueio anterior.

b. O sistema exibe uma mensagem confirmando o desbloqueio do veículo.

(5) Falha na ação

a. O usuário é alertado com uma mensagem de indisponibilidade momentânea, porém incentivado a tentar novamente.\\\hline
Pós-condições &
~\\\hline
Requisitos não funcionais &
~\\\hline
Autor &
Leandro Bentes\\\hline
Data &
15/04/2013\\\hline
\end{supertabular}
\end{flushleft}

\section{Arquitetura do Sistema}

Baseado no modelo conceitual, nos casos de uso, suas descrições e pesquisa de trabalhos correlatos,
é possível estabelecer um modelo arquitetural transcrito em um diagrama de componentes UML, 
seguindo recomendações estabelecidas para sistemas de tempo real de acordo com \textcite{Mendes:2002}.
Nesta etapa da modelagem são definidas algumas tecnologias utilizadas, uso de serviços externos e protocolos
de comunicação. A Figura 3.3 mostra o diagrama de componentes da UML gerado.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/4_arquitetural.png}
\caption{Arquitetura do Sistema}
\label{Figura 3}
\end{figure}


Pela definição arquitetural obteve-se um cenário onde existem dois componentes macro: o módulo veicular e o módulo Web chamado WebManager.

O módulo veicular pode ser destrinchado em diversos subcomponentes, interfaces requeridas e interfaces fornecidas conforme a descrições a seguir.

\begin{itemize}
	\item Serviço GPS: representa a utilização do serviço de rádio fornecido pelos satélites/estações GPS;
	\item Módulo GPS: hardware que implementa as funcionalidade GPS, se comunicando com o microcontrolador por um canal serial descrito como Serial GPS;
	\item MicroControlador: componente físico que ATmega328 da placa Arduino;
	\item Digital I/O: Pinos digitais do microcontrolador que interagem com o I/O Veículo;
	\item I/O Veículo: Hardware que implementa o chaveamento para desligamento do veículo;
	\item Módulo GSM/GPRS: hardware que implementa funcionalidade de celular para acesso a rede GPRS. Se comunica com o microcontrolador por meio de um canal serial nomeado Serial GSM;
\end{itemize}

O módulo nomeado WebManager realiza o gerenciamento e aplicação das regras de negócio, interface com usuário e diponibilização do webservice. Seus principais componentes são:

\begin{itemize}
	\item REST API For Embedded: interface pela qual o módulo embarcado se comunica com o WebManager, é um webservice RESTful pronto para receber e responder às requisições dos módulos;
	\item Builder Sessão: gerenciador de sessões web necessário para dados transientes;
	\item Controller: componente que representa o conjunto de controllers (MVC) que atuam dentro do WebManager, manipulando requisições de módulos e usuários;
	\item IDao: Interfaces para acesso aos DAOs, os controllers possuem instâncias dessas interfaces para obter acesso ao banco;
	\item DAOs: Implementação dos DAOs que contém os scripts de consulta ao banco de dados;
	\item Banco de Dados: representação do conjunto de dados relacionais do WebManager armazenados;
	\item Controller API: Interface para os controllers por onde estes oferecem serviços a outros componentes;
	\item Security Framework: Componente responsável pela autenticação, autorização e controle de acesso ao sistema web. Utilizado para controle de perfis de usuários;
	\item UI Framework: Framework utilizado para implementação das views do sistema (páginas HTML);
	\item Maps API: Indica necessidade de acesso a um serviço de mapas de terceiros para representação visual no sistema.
\end{itemize}

\section{Modelo de classes para o módulo embarcado}

Para descrever os comportamentos de cada componente e integrá-los de forma lógica um Diagrama de Classes
é desenhado, uma vez que a orientação a objetos atende de forma completa a descrição do conjunto de hardware.
Pode-se abstrair comportamentos e representá-los através de métodos e abstrair estados como atributos de uma classe. 

A principal vantagem em modelar os componentes de hardware com o digrama de classes é observada
no momento de escrever funções ou bibliotecas para comunicação entre componentes, pois como o 
mapeamento de métodos necessários já está feito, o desenvolvimento é focado apenas nestes,
evitando a criação de código não utilizado. 

Para exemplificar esta situação, neste projeto o componente GSM fornece uma gama de funcionalidade 
que não são utilizadas, como funções de chamada de voz, mensagem SMS e outras,
porém como o modelo prevê apenas comportamentos relacionados a funções GPRS,
não foi despendido tempo com a implementação de serviços para acessar estas funcionalidades. 

A Figura 3.4 mostra o diagrama de classes UML que abstrai as funcionalidades do módulo veicular embarcado e 
o representa de forma estruturada lógica.

\newpage

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{figures/5_mod_veicular.png}
\caption{Diagrama de Classes do Módulo Veicular}
\label{1}
\end{figure}

Conforme se observa no desenho de classes, o módulo se resume a quatro classes, onde existe uma composição na classe principal ModuloVeicularHw, isto significa que esta é só existe juntamente com as outras da composição e se uma destas últimas for removida a principal deixará de existir. Ainda na classe principal são guardados os atributos de estado, conexão e posição atual, além de alguns atributos para verificação de erros.

A classe GSM possui como atributo principal um lista de comandos AT, utilizados para acionar as diversas funções de celular, estes comandos são strings definidas pelo fabricante e descritas no manual do produto. Nota-se que apenas métodos relacionados com a função GPRS e conexões de rede dados foram mapeados, pois só existe a necessidade de uso nesta modalidade.

No modelo da classe GPS, os atributos principais utilizados para obter posição geográfica atual são latitude e longitude, porém para o funcionamento do hardware
dados de altitude, data, hora e número de satélites também são utilizados. Como comportamentos padrão existem: a obtenção da posição atual, velocidade, curso, satélites e data com hora.

O componente IO Veículo apenas representa as ações de bloquear, desbloquear e estado do alarme (não utilizado neste projeto). Como atributos, o estado do alarme e estado de bloqueio são representados.

\section{Hardware do módulo embarcado}

Conforme abordado no capítulo 2, a plataforma de prototipagem Arduino foi escolhida para servir de base para implementação em hardware do módulo embarcado, sendo que a placa controladora Arduino Uno é o núcleo funcional do mesmo. 

Baseado no modelo de classes da figura 3.4, é possível perceber que existe uma correspondência de um para um entre classe e hardware que implementa certa funcionalidade, assim sendo:

\begin{itemize}
	\item Classe ModuloVeicularHw: corresponde a placa controladora Arduino Uno.
	\item Classe GSM: corresponde em hardware ao Shield GSM que está acoplado a placa controladora.
	\item Classe GPS: corresponde ao Shield GPS com módulo GPS EM406 descrito no capítulo 2.
	\item IO Veículo: correspondente ao módulo de relé para acionamento de cargas em conjunto com um pino digital da placa controladora para realizar leitura do estado do alarme do veículo.
\end{itemize}

\subsection{Placa controladora}

O processo de montagem se inicia com a placa microcontroladora que recebe os shields conforme o desenvolvimento do firmware. A figura 3.5 mostra o exemplar de Arduino Uno adquirido para montagem do protótipo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/arduinoUnoReal.jpg}
	\caption{Exemplar Arduino Uno}
	\label{1}
\end{figure}

Por serem parte de uma plataforma orientada a prototipagem, os hardwares da família Arduino possuim algumas características para facilitar a integração entre módulos, placas de circuito impresso e componentes de outra natureza, é possível enumerar as principais:

\begin{enumerate}
	\item Layout padrão: os shields seguem o mesmo desenho da placa controladora Arduino Uno, com issso não existe desproporcionalidade de tamanho na integração.
	\item Pinos para empilhamento: as placas possuem pinos passantes que permitem conectar nós de circuito a uma segunda placa empilhada sob a primeira. Os pinos são mostrados na figura 3.6.
	
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/stackPins.jpg}
	\caption{Pinos para empilhamento no Shield GSM}
	\label{1}
\end{figure}	

	\item O kit Arduino traz um conjunto de jumpers com terminais do tipo pino, facilmente conectáveis aos soquetes da placa controladora.
	\item Textos explicativos impressos sobre as placas descrevem a função de cada pino, diminuindo riscos de conexões erradas que podem levar à queima de componentes.
	
\end{enumerate}

\subsection{Shield GSM}

O próximo componente integrado é o Shield GSM, nesta etapa apenas é necessária a soldagem do pinos de empilhamento conforme a figura 3.6, e encaixar o conjunto sobre a placa controladora.

Conforme obtido na documentação disponibilizada pelo fabricante, este shield utiliza alimentação dos pinos 5V e 3.3V, além disso faz uso dos pino digitais 2 e 3 para abertura de um canal serial com o microcontrolador, o restante dos pinos fica livre para uso. Existe um conector para antena padrão SMA, que recebe uma atena quad band afim de melhorar a recepção de sinal da rede GSM. A figura 3.7 mostra a integração realizada.
 
\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/arduinoAndGSM.jpg}
\caption{Shield GSM integrado ao Arduino Uno}
\label{1}
\end{figure}

\subsection{Shield GPS}

A próxima etapa é a integração do Shield GPS no conjunto atual, para isto se procede a soldagem dos pinos de empilhamento da mesma forma que no passo anterior, porém foi percebido na análise documental que existe um pequeno empecilho que demanda uma adaptção no hardware.

A questão é que o Shield GPS, assim como o GSM, também necessita de um canal serial com o microcontrolador. Em sua configuração padrão, este componente possui uma chave que permite alternar o canal serial entre os pares de pino 0-1 e 2-3, neste momento surge o problema:

\begin{itemize}
	\item Os pinos 0 e 1 formam o canal serial utilizado para programação e debug do microcontrolador via porta USB, portanto não é possível utilizá-lo nesta configuração.
	\item Os pinos 2 e 3 são utilizados pelo Shield GSM e não se pode compartilhar o mesmo canal.
\end{itemize}

A solução aplicada foi alterar os pinos do canal serial para o par 4-5 que se encontra livre. O desenho do shield permite fazer isto facilmente: conforme a figura 3.8, existem dois pontos de solda no circuito com os textos "2" e "3", deve-se remover o pontos de solda desses locais e realizar um jumpeamento do ponto 2 para o pino 4 e do ponto 3 para o pino 5. A chave de seleção deve ser mantida na posição DLINE.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/gpsMod.jpg}
\caption{Modificação no Shield GPS}
\label{1}
\end{figure}  

Após a modificação se procede o empilhamento da placa normalmente, deixando o conjunto com o aspecto da figura 3.9.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/arduinoGSMGPS.jpg}
\caption{Integração Arduino Uno, GSM e GPS}
\label{1}
\end{figure}

\subsection{Circuito de I/O com Veículo}

Um dos requisitos do sistema é a possibilidade de bloquear, ou seja, desligar o veículo e não permitir que o mesmo seja ligado novamente por meios normais. Após pesquisar sobre os métodos utilizados pelos alarmes automotivos para realizar este desligamento foi constatado que o mesmos comumente realizam uma intervenção sobre o circuito da bomba de combustível do veículo.

O funcionamento desta técnica se baseia no princípio de malhas fechadas, a figura 3.10 representa o circuito de uma bomba de combustível automotiva: uma vez que a ignição fecha o circuito, a bomba fica alimentada e funciona normalmente.

 \begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/circBomba.png}
\caption{Circuito normal da bomba de combustível}
\label{1}
\end{figure}

A intervenção se dá na inserção de uma nova chave, neste caso um relé normalmente fechado\footnote{Um relé normalmente fechado permite a passagem de corrente entre dois pontos e, quando acionado, desconecta estes dois ponto impedindo a condução e abrindo o circuito.} é colocado em série com a chave de ignição, no momento que o microcontrolador acionar o relé, o circuito é aberto e a bomba deixa de funcionar por falta de alimentação. A figura 3.11 mostra o circuito alterado e a chave representativa do relé se encontra aberta, indicando um bloqueio do veículo.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/circBombaFin.png}
\caption{Circuito da bomba após intervenção}
\label{1}
\end{figure}

A bomba de combustível de um automóvel possui uma corrente de operação de 5 a 6 ampéres, com pico de 10 ampéres, conforme relatado no capítulo 2, um microcontrolador necessita de um circuito externo, em geral feito com relés, para manipular esta carga. Para suprir esta necessidade foi adquirido um circuito com relé da fabricante Sparkfun. Detalhes deste componente se encontram no capítulo 2.

A integração deste circuito ao conjunto montado até o momento é feita por meio de três jumpers:

\begin{itemize}
	\item Jumper ligado em 5 V para alimentação da bobina do relé.
	\item Jumper ligado em GND (terra) também para a bobina;
  \intem Jumper de controle ligado no pino digital 12 para sinalizar o acionamento ou desligamento do relé.
\end{itemize}

Uma intervenção no circuito de relé foi necessária pois por padrão o conector da placa está interligado à malha normalmente aberta, com isso foram soldados dois cabos diretamente à malha normalmente fechada conforme a figura 3.12.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/jmpNC.jpg}
\caption{Fios interligados à malha normalmente fechada do relé}
\label{1}
\end{figure}

Ao final jumper também foi adicionado interligando o pino digital 9 ao pino RST para fins de reboot automático do microcontrolador quando necessário. A figura 3.13 mostra o conjunto completo montado.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.6\textwidth]{figures/fullMount.jpg}
\caption{Conjunto de hardware do módulo embarcado montado}
\label{1}
\end{figure}

\section {Desenvolvimento do Firmware}

O módulo embarcado possui um software de propósito específico, ou firmware, gravado na memória flash do microcontrolador, cujas principais funções são:

\begin{itemize}
	\item Comunicação e obtenção de dados GPS;
	\item Montagem do corpo da requisição ao webservice;
	\item Controle da conexão e transmissão de dados GPRS;
	\item Manipulação da resposta e tratamento de bloqueio/desbloqueio do veículo através do módulo de IO;
\end{itemize}

A criação desta rotina segue um modelo de atividades bem definidas, que se restringem a um laço de repetição principal. O modelo de programação da plataforma Arduino engloba a implementação de duas funções principais:

\begin{itemize}
	\item void setup(): função que é executada apenas uma vez a cada inicialização ou reboot da placa controladora, utilizada para inicialização de variáveis, configuração do modo dos pinos e bibliotecas.
	\item void loop(): bloco executado após o setup(), fazendo o que o próprio nome diz, um laço de repetição que executa enquanto o microcontrolador estiver ligado, permitindo a leitura e modificação de estado. Utilizado para realizar o controle efetivo da placa controladora.
\end{itemize} 

O passos fundamentais do firmware no módulo embarcado são descritas no diagrama de atividades da figura 3.14, o fluxo principal se resume, após a execução da função setup, na repetição da obtenção dos dados GPS, envio dos dados ao servidor e leitura da resposta, verificando se deve se efetuar o bloqueio do veículo ou não.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/atividades_hl.png}
\caption{Sequência lógica do firmware}
\label{1}
\end{figure}

Para realização das atividades que envolvem o uso dos shields e outros hardwares acoplados a placa controladora, é necessário criar uma interface de comunicação com os mesmos, que é feita na maioria dos casos, utilizando uma biblioteca fornecida pelo fabricante ou pela comunidade Arduino. Estas bibliotecas são conjuntos de rotinas escritas em C/C++ e integradas ao programa principal por meio de uma diretiva \emph{\#include<biblioteca.h>}.

As subseções a seguir descrevem a realização da interface com os shields GPS e GSM, além da comunicação com o módulo de IO (relé) e uso da funcionalidade EEPROM, que permite persistir um dado em memória não-volátil, recuperando seu estado em caso de reinicialização da placa.

\subsection{Interface com EEPROM}

O microcontrolador da placa Arduino possui uma memória do tipo EEPROM: Electrically-Erasable Programmable Read-Only Memory, com tamanho de 1024 bytes no ATmega328. Neste tipo de memória os valores armazenados são mantidos mesmo que a placa seja desligada, atuando como um disco rígido para armazenamento não-volátil.

Este componente é essencial para realizar a persistência do estado de bloqueio do módulo embarcado, evitando que por um simples desligamento e religamento da bateria ocorra o desbloqueio do automóvel. A cada boot o último estado é restaurado e a cada alteração do mesmo, há uma atualização do valor na EEPROM.

A manipulação da EEPROM consiste na leitura e na escrita de dados, para ambos é necessário incluir o cabeçalho \#include<EEPROM.h>. 

A escrita de dados é feita pela função EEPROM.write(endereço, valor), onde endereço é um inteiro de 0 a 1023 e valor é um byte, aceitando valores de 0 a 255. Para leitura, a função EEPROM.read(endereço) é usada, bastando passar o valor do endereço como parâmetro e obter um byte como resposta.

O processo de leitura do último estado e de escrita do estado atual do módulo na memória EEPROM é mostrado no código 3.6.1.

\renewcommand{\baselinestretch}{0.5}  % distância entre linhas
\begin{codigo}[htb]
\fontsize{9pt}{9pt}\selectfont
      \begin{boxit}  % coloca o código dentro de um Box
      \vspace{2mm}
      \VerbatimInput[xleftmargin=8mm,numbers=left,obeytabs=true]{sources/eeprom_write.cpp}
   \end{boxit}
   \caption{\it Rotinas de leitura e escrita em EEPROM}
   \label{code:eeprom}
\end{codigo}

\newpage

\subsection{Interface com IO}

A interface com o módulo de IO com relé é bastante simplificada, uma vez que sua integração é realizada por meio dos pinos digitais. O processo basicamente define que o pino de comunicação utilizado tenha seu modo de operação (entrada ou saída) definido na função setup, depois disso, basta realizar uma chamada da função digitalWrite(pino, estado), onde o parâmetro pino é o número do mesmo assim como descrito na impressão sobre o circuito impresso, e o parâmetro estado pode assumir o valor da macro HIGH (ligado) ou LOW (desligado). O código 3.6.2 mostra a configuração e uso do pino de digital para acionamento ou desacionamento do relé de controle de carga.

\renewcommand{\baselinestretch}{0.5}  % distância entre linhas
\begin{codigo}[htb]
\fontsize{9pt}{9pt}\selectfont
      \begin{boxit}  % coloca o código dentro de um Box
      \vspace{2mm}
      \VerbatimInput[xleftmargin=8mm,numbers=left,obeytabs=true]{sources/io.cpp}
   \end{boxit}
   \caption{\it Rotinas de leitura e escrita em EEPROM}
   \label{code:eeprom}
\end{codigo}
  

\subsection{Interface com Shield GPS}

O Shield GPS fornece está acoplado fisicamente à placa Arduino Uno e se comunicando por um canal serial estabelecido nos pinos 4 e 5 conforme abordado na seção 3.5.3, entretanto é preciso configurar este canal na inicialização do controlador e obter os dados enviados pelo módulo.

Para obtenção dos dados de posicionamento, dois artefatos necessitam estar presentes no código: 

\begin{itemize}
	\item Um canal serial lógico: feito utilizando a biblioteca SoftwareSerial, utilizado para efetuar a troca de dados bidirecional entre o microcontrolador e o módulo GPS.
	\item Um parser das mensagens GPRMC: a biblioteca TinyGPS disponibilizada pela comunidade realiza esta função, capturando as mesagens transmitidas pelo módulo e disponibilizando as informações 
\end{itemize}

Além de configurar os itens citados, é necessário que o módulo tenha completado a montagem da mensagem GPRMC (citada no capítulo 2), para isto é criada uma função auxiliar chamada feedGps() que faz uma checagem contínua no status da mensagem por meio de um laço de repetição, que é interrompido caso a mensagem esteja completa ou ocorra um timeout sem resposta.

O Código 3.6.3 mosta as chamadas necessárias para capturar a posição atual do módulo GPS.

\renewcommand{\baselinestretch}{0.5}  % distância entre linhas
\begin{codigo}[htb]
\fontsize{9pt}{9pt}\selectfont
      \begin{boxit}  % coloca o código dentro de um Box
      \vspace{2mm}
      \VerbatimInput[xleftmargin=8mm,numbers=left,obeytabs=true]{sources/codegps.cpp}
   \end{boxit}
   \caption{\it Rotinas de obter a posição geográfica via GPS}
   \label{code:codegps}
\end{codigo}


\subsection{Interface com Shield GSM}
O módulo SM5100B do Shiels GSM não possui uma biblioteca do fabricante com funções pré-definidas para sua 
operação, mas é operável por meio de comandos AT especificados em suas referências. Entretanto,
o uso direto de comandos AT insere duplicações no código fonte, eleva o consumo de memória,
torna bastante complexo o controle de estados e a recuperação de erros. Para contornar esta questão,
foi implementada uma classe de comunicação com o módulo, que é uma subclasse de SoftwareSerial, que por
sua vez é uma classe de comunicação serial RS 232 com controle via software. A figura 3.15 mostra o diagrama
da classe de comunicação e a herança de SoftwareSerial.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/lib_gsm.png}
	\caption{Classe de comunicação com SM5100B}
	\label{1}
\end{figure}

\subsection{Requisição Webservice}

O módulo veicular embarcado se comunica com o servidor web através de requisições HTTP POST, trazendo em seu
payload dados estruturados no padrão JSON. O adoção do método POST se deu pois o permite um maior tamanho de
mensagem, e como nesta mensagem são enviados dados autenticação, estes valores não seria gravados em texto
plano nos logs, como acontece com o GET. A estrutura JSON traz os seguintes campos:

\begin{itemize}
	\item idModule: código serial do módulo usado como identificador único na base de dados do sistema web.
	\item codAccess: usado como senha para validação da autenticidade do módulo.
	\item latitude: latitude geográfica atual obtida pelo GPS.
	\item longitude: longitude geográfica atual obtida pelo GPS.
	\item alarm: valor representando se o alarme do veículo foi acionado, 0 se falso 1 se verdadeiro. Não utilizado no momento.
\end{itemize}

A figura 3.16 mostra a mensagem enviada pelo módulo veicular a um servidor de testes, é possível observer o cabeçalho HTTP simulando um browser com engine Mozilla/5.0 e a sinalização do uso de dados estruturados JSON.


\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth]{figures/requisicao_post.png}
	\caption{Requisição HTTP feita pelo módulo veicular}
	\label{1}
\end{figure}

\section{Módulo Web (WebManager) - Introdução}

O módulo web, ou WebManager, é a aplicação que roda na internet responsável por receber e armezenar os dados vindos do módulo embarcado, transmitir comandos para este e permitir a interação do usuário com o sistema. O WebManager conta com um webservice RESTful que é responsável pela comunicação com o módulo embarcado.

Um webservice é uma solução adotada na integração de sistemas que funcionam em diferentes arquiteturas de hardware, normalizando a troca de informações para um formato (linguagem) universal, em geral uma combinação de uso do protocolo HTTP e dados estruturados XML/JSON. 

A técnica REST permite fazer mapeamentos de métodos diretamente em URL com correspondência aos métodos HTTP, por exemplo, uma método de uma classe Java pode ser mapeado para uma URL chamada via método GET.

A implementação do WebManager como um todo foi feita utilizando a linguagem Java, por possuir um nível de maturidade muito alto para aplicações e serviços Web, contando com uma extensa gama de frameworks para os mais diversos fins, como mapeamento objeto-relacional, interface com o usuário,  webservices e outros.

Como banco de dados, o PostgreSQL foi adotado  pois possui um sofisticado mecanismo de bloqueio, suporta tamanhos ilimitados de linhas, bancos de dados e tabelas (até 16TB), aceita vários tipos de sub-consultas, possui mais tipos de dados e conta com um bom mecanismo de FAILSAVE (Segurança contra falhas, por exemplo no desligamento repentino do sistema).

\section{Módulo Web (WebManager) - Modelagem}

A arquitetura da modelagam do WebManager foi baseada no Pattern MVC que segundo \textcite{Mendes:2002} estabelece o desenvolvimento de software em camadas: classes de Entidade (Models), classes de controle (Control) e classes de interface com o usuário (View). 

O modelo MVC é consagrado, pois permite o desacoplamento das camadas de software facilitando a manutenção e diminuindo a repetição de código, as vantagens de sua utilização ficam bastante claras quando existe a necessidade da alteração de código, por exemplo, caso haja mudança nas regras de negócio de algum cálculo do sistema, apenas é necessária atualização do conteúdo da camada Control. Além do modelo arquitetural base, alguns padrões de projeto como Singleton (utilizado no Security Framework e DAO's) e Facade (agregando funções de diversas interfaces a uma interface centralizada que é exposta para os subsistemas), descritos por \textcite{Gamma:2000}, foram aplicados pois o uso de padrões de projeto fornece soluções arquiteturais otimizadas para problemas conhecidos na engenharia de software. A Figura 12 mostra o diagrama de classes obtido.

\begin{landscape}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=20.00cm\textwidth]{figures/6_web_manager.png}
	\caption{Modelo de classes do WebManager}
	\label{Figura 12}
\end{figure}
\end{landscape}

\section{Módulo Web (WebManager) - Desenvolvimento}
A implementação em do código do WebManager contemplou primeiramente o webservice e as camadas de model e controllers, deixando a implementação da interface com o usuário como última etapa. A modelagem de banco de dados utilizando modelo entidade-relacionamento não foi necessária, uma vez que a camada Model contendo as entidades do sistema sofreu um mapeamento objeto-realcional (ORM) feito pelo framework Hibernate. Este mapeamento isenta o desenvolvedor de criar na maioria dos casos, cláusulas SQL, deixando-o apenas com o trabalho de manipular instâncias de classes e seus atributos. A camada de entidades é mostrada na figura 13.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/model.png}
	\caption{Model - Entidades do sistema}
	\label{Figura 13}
\end{figure}

O funcionamento do módulo web é bastante simples, um usuário acessa o sistema por meio de um login e senha fornecidos, em caso de sucesso é direcionado à página de rastreamento onde pode efetuar a seleção do veículo pertencente a ele a fim de ralizar o rastreamento, ação esta que é exibida em um mapa da API Google Maps. A figura 14 mostra a tela de login do sistema e a figura 15 exibe a tela de rastreamento principal.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/webmanager_login.png}
	\caption{Tela de Login do Sistema}
	\label{Figura 14}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=15.00cm\textwidth]{figures/webmanager_rastrear.png}
	\caption{Tela de Rastreamento}
	\label{Figura 15}
\end{figure}

\hfill


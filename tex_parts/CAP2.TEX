\chapter{Referencial Tecnol\'{o}gico}
\label{cap:referencial tecnologico}


\section{Sistema Embarcado}

Segundo \textcite{Wolf:2001}, um sistema de computação embarcado é qualquer dispositivo que inclui um computador programável, o qual não é direcionado para resolver problemas de propósito geral, mas sim uma situação ou necessidade específica, operando geralmente com recursos limitados e executando algoritmos para resposta em tempo real.

A diferenciação entre um sistema embarcado de um sistema de propósito geral se dá por algumas características:
\begin{itemize}
	\item \emph{Tempo real}: a resposta do sistema deve ser dada em um tempo limite. Caso a resposta venha fora do limite de tempo aceitável, o sistema pode se tornar instável, parar de funcionar ou realizar ações fora do previsto gerando danos catastróficos. 
	\item \emph{Diferentes taxas de entrada de dados}: um sistema embarcado pode receber diversas entradas de dados com velocidades diferentes, ele deve tratar esta situação e oferecer uma saída sincronizada e sem perdas.
	\item \emph{Custo de produção}: todos os componentes de hardware devem ser escolhidos para minimizar o custo de produção, por isso, um projeto cuidadosamente elaborado se faz necessário.
	\item \emph{Consumo de energia}: conjunto hardware/software dever ser projetado de tal maneira que o consumo de recursos energéticos seja sempre o mínimo possível. Um elevado consumo influi tanto no custo de produção  quanto no custo de operação.
\end{itemize}

Um exemplo de sistema embarcado a se considerar é um roteador wireless conforme a figura \ref{fig:roteador}, pois possui as seguintes características:

\begin{itemize}
	\item É um computador de propósito específico: realiza funções de roteamento, controle de conexões, controle do sinal de rádio e implementa serviços da camada física a camada de rede TCP/IP;
	\item Opera em tempo real: todos os pacotes que passam pelo roteador deve ser processados em tempo hábil;
	\item Custo de produção reduzido: São utilizados processadores de custo reduzido, quantidade de memória limitada e outros componentes de menor custo a fim de reduzir o preço total e facilitar a produção em massa.
\end{itemize}

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.4\textwidth]{figures/embarcado_exemplo.jpg}
			\caption{Exemplo de sistema embarcado: roteador wireless}
			\label{fig:roteador}
	\end{figure}


\hfill

\section{Projeto de Sistemas Embarcados}

Modelos para projeto de sistemas embarcados têm sido propostos ao longo dos anos, como é caso do Embedded UML proposto por \textcite{Martin:2001}, que é um profile UML representando a síntese de várias ideias discutidas pela comunidade que adota UML no projeto de aplicações de tempo real. 

Foram selecionadas as melhores práticas de análise e especificação de requisitos para sistemas os quais necessitam que hardware e software sejam co-projetados, introduzido um conceito de mapeamento da plataforma para gerar uma implementação otimizada de hardware e software, uma vez que conforme \textcite{Wolf:2001}, o custo de produção e o consumo de recursos energéticos deve ser o mínimo possível.

Esta metodologia fornece uma abordagem que permite o desenvolvimento de ferramentas de análise automatizada, simulação, síntese e geração de código enquanto se define um padrão UML para embarcados.

Em um segundo artigo, \textcite{Martin:2002} propõe novas extensões UML que cobrem lacunas não atendidas pela linguagem, como suporte a modelagem de hardware baseada em VHDL.

Na UML existem algumas limitações de análise de cenários com requisitos não funcionais, que no caso de embarcados têm prioridade igual a dos requisitos funcionais e de suma importância para a confiabilidade do sistema. Esta limitação é descrita por \textcite{Espinoza:2008} que propõem práticas complementares para analisar estes requisitos não funcionais, a fim de tornar os sistemas mais eficientes de confiáveis.

\textcite{Wolf:2001} propõe uma abstração em alto nível dos principais passos no projeto de sistemas embarcados em uma abordagem \textit{top-down}, são estes:

\begin{itemize}
	\item \emph{Requisitos}: são obtidas informações sobre o que se desenvolver no sistema, obter os requisitos esperados pelo cliente/usuário e extrair apenas o que for importante para o projeto. Requisitos funcionais e não funcionais são levados em conta.
	\item \emph{Especificação}: etapa em que se realiza o mapeamento dos requisitos funcionais de um sistema embarcado, quais funções ele deve fornecer ao usuário. Os Casos de Uso da UML são um meio de documentar os requisitos.
	\item \emph{Projeto Arquitetural}: nesta etapa é feita a quebra do sistema em componentes de alto nível e como eles se integram e se comunicam. A UML oferece o Diagrama de Componentes para esta finalidade.
	\item \emph{Projeto de componentes de hardware e software}: para cada componente definido, são mapeados seus atributos e métodos, levando a uma abordagem utilizando Orientação a Objetos. O Diagrama de Classes da UML permite fazer este tipo de representação.
	 \item \emph{Integração do sistema}: após a construção de cada componente de hardware e implementação dos componentes de software, estes são integrados.
\end{itemize}
\textcite{Marwedel:2001}  inclui etapas de teste dentro das etapas de projeto, designando o fluxo como modelo-V. As etapas de teste são: 

\begin{itemize}
	\item \emph{Testes unitários}: Teste individual para cada unidade mínima funcional do sistema, com isto é possível verificar o comportamento de cada parte e, em caso de defeitos, corrigi-los antes de qualquer integração, poupando tempo de desenvolvimento uma vez que seria dispendioso, depois do sistema pronto, rastrear e encontrar o problema.
	\item \emph{Testes de integração}: Verificação da comunicação entre os diferentes componentes quando interligados. Esta etapa é válida pois mesmo que os componentes funcionem individualmente e separados, sempre que se integram partes um novo comportamento é gerado, o que pode levar a erros inesperados.
	\item \emph{Aceitação e Uso}: Verifica-se o comportamento do sistema em relação ao descrito nas especificações, é um teste do sistema completo e em funcionamento, para confirmação se todos os requisitos estão sendo atendidos.
\end{itemize}


\newpage
\section{Microcontroladores}

Um microcontrolador é uma unidade de processamento que, diferente de um microprocessador, traz todos os módulos necessários ao seu funcionamento (como memória volátil, memória somente leitura, blocos de entrada e saída, conversores analógico-digital e digital-analógico, linhas para troca de dados com componentes externos) no interior de um único chip, podendo assim ser programado para executar uma rotina de propósito específico.

Realizando uma comparação com os microprocessadores, pode-se constatar que os microcontroladores operam em uma frequência muito baixa, porém adequada a maioria das aplicações as quais são designados, como por exemplo: controlar uma esteira, uma caldeira ou uma máquina. Devido a esta característica, o consumo de energia é pequeno, normalmente na casa dos miliwatts, além disso os microcontroladores podem entrar em modo de espera, aguardando por um evento externo, tal como pressionar de uma tecla ou acionamento de um sensor.

Uma outra característica antagônica em relação a um microprocessador é que, enquanto neste último é feito um superdimensionamento de recursos sendo limitado pela faixa financeira que o usuário pode investir, em um projeto com microcontroladores o superdimensionamento é um erro de projeto, um desperdício de recurso que reflete diretamente no preço do equipamento final, sendo multiplicado no caso de uma produção em larga escala.

As aplicações deste componente compreendem principalmente automação e controle de produto periféricos, como sistemas de controle de motores automotivos, máquinas industriais, de escritório e residenciais, brinquedos, sistemas de supervisão e outros. Por reduzir o tamanho, custo e consumo de energia se comparados ao microprocessadores, se tornam uma alternativa eficiente para controlar processos e aplicações. A figura \ref{fig:atmegabloc} mostra um microcontrolador da fabricante Atmel, pode-se observar que ele possui um único encapsulamento com componentes básicos ao seu funcionamento embutidos.


\begin{figure}[h!]
			\centering
			\includegraphics[width=0.6\textwidth]{figures/microcont_atm.jpg}
			\caption{Microcontrolador Atmel}
			\label{fig:atmegabloc}
	\end{figure}

\newpage
\section{Plataforma Arduino}

Arduino é uma plataforma para prototipagem eletrônica que utiliza o conceito de hardware livre. Neste conceito deve-se prover a disponibilização irrestrita de informações sobre o projeto de hardware, tais como digramas eletrônicos, estrutura de produtos, layout de placas de circuito impresso, rotinas de baixo nível e qualquer outra informação necessária para um construção \textit{from-scratch} do projeto.

Os modelos mais utilizados da placa microcontroladora Arduino (Duemilanove e Uno) foram concebidas com base em um microcontrolador Atmel AVR montado em placa única, possui suporte de entra/saída embutido, uma linguagem de programação padrão baseada em C/C++.

A plataforma surgiu para que amadores, entusiastas e outras pessoas que não teriam acesso ao controladores e ferramentas mais sofisticadas, pudessem criar seus projetos, tornando-os acessíveis, flexíveis e com baixo custo. Uma placa Arduino, em geral, possui os seguintes elementos em sua construção:

\begin{itemize}
	\item Um microcontrolador
	\item Placa base com reguladores de voltagem adequados ao microcontrolador.
	\item Linhas de Entrada/Saída digitais e analógicas.
	\item Linhas de comunicação serial.
	\item Interface USB para programação e interação com um computador hospedeiro.
\end{itemize} 

Seguindo estas características comuns, ao decorrer da existência do projeto foram desenvolvidas diversas placas microcontroladoras, cada uma carrega um codinome e especificações de hardware próprias. A tabela 2.1 descreve algumas placas da família Arduino.

\begin{table}[!h]
\caption{Modelos de placa Arduino}

	\begin{tabular}{|r|c|c|c|c|c|}
		\hline 
			\textbf{Modelo} & \textbf{Clock} & \textbf{E/S Digital} & \textbf{E/S Analógico} & \textbf{Alimentação} & \textbf{Flash}
		\\
		\hline
			Arduino Due (ARM) & 84MHz & 54 & 12 & 7-12V & 512 KB
		\\
		\hline
			Arduino Leonardo & 16MHz & 20 & 12 & 7-12V & 32 KB
		\\
		\hline
			\textbf{Arduino Uno} & 16MHz & 14 & 6 & 7-12V & 32 KB
		\\
		\hline
			Arduino Duemilanove & 16MHz & 14 & 6 & 7-12V & 32 KB
		\\
		\hline
			Arduino Pro & 8MHz & 14 & 6 & 3.3-12V & 32 KB
		\\
		\hline
			Arduino Mega & 16MHz & 54 & 16 & 7-12V & 256 KB
		\\
		\hline
			Arduino Mini 05 & 16MHz & 14 & 6 & 7-9V & 32 KB
		\\
		\hline
			Arduino Fio & 8MHz & 14 & 8 & 3.3-12V & 32 KB
		\\
		\hline
			LilyPad Arduino & 8MHz & 14 & 6 & 2.7-5.5V & 32 KB
		\\


\hline
\end{tabular}
\end{table}

Uma possibilidade bastante interessante para projetos que utilizam a plataforma Arduino é a expansão da placa microcontroladora através da agregação de novos hardwares, estes chamados de \textit{shields}.

\subsection{Arduino Shields}

Placas Arduinos e outras baseadas no projeto utilizam expansões de hardware chamadas \textit{shields}. São placas de circuito impresso fixadas ao topo da placa microcontroladora através dos pinos de conexão e se comunicam com a unidade principal através dos canais de Entrada/Saída analógicos ou digitais, ou ainda, através do canal de comunicação serial.

Caso não utilizem a mesma pinagem, pode-se empilhar diversos shields na mesma placa controladora. A idéia destas expansões é criar componentes com determinada especialização, muito similar ao conceito de framework em software. Existem shields para as mais diversas aplicações como:

\begin{itemize}
	\item Conectividade em rede Ethernet
	\item Conectividade em rede Zigbee
	\item Conectividade em rede Wireless 802.11
	\item Controle de motores
	\item Conexão com rede celular GPRS
	\item Funcionalidade GPS
	\item Middleware Android
	\item Controle de Relés
	\item Bluetooh
	\item Sintetizador de Voz
\end{itemize}

A figura \ref{fig:arduinoshields} mostra uma placa Arduino Uno conectada a dois shields para controle de motores. Pode-se observar a facilidade de conexão entre os componentes, uma vez que utilizam um layout de pinagem padronizado.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.4\textwidth]{figures/arduino_with_shield.jpg}
			\caption{Ilustra\c{c}\~{a}o da placa Arduino com shields conectados}
			\label{fig:arduinoshields}
\end{figure}

\newpage
\section {Placa Arduino Uno}

Para realizar a implementação deste projeto, optou-se por utilizar uma placa Arduino Uno pois projetos similares utilizaram esta placa sem problemas de sub ou super dimensionamento, ou seja, suas especificações atendem exatamente a necessidade do projeto, seu layout permite a conexão da maioria dos shields disponíveis e existe documentação disponível na Internet.

A placa Arduino Uno é baseada no microcontrolador ATmega328, possuindo 14 pinos de entrada/saída digitais (dos quais 6 podem ser utilizados como saída PWM), 6 entradas analógicas, cristal de cerâmica com 16 MHz de clock que define a frequência de operação do microcontrolador, conexão USB, pino de alimentação externa padrão barrel e botão de reset. A placa possui todos os circuitos auxiliares para o funcionamento do microcontrolador, bastando ao usuário conectá-la a um computador via cabo USB para começar a utilizá-la, além disso o processo de gravação de rotinas é facilitado por haver um \textit{bootloader}\footnote{\textit{Bootloader} é o gerenciador de inicialização do microcontrolador.} que automatiza este passo (\textcite{arduino_specs:2013}).

A figura \ref{fig:arduinouno} exibe uma tomada frontal da placa Arduino Uno onde é visível o microcontrolador ATmega328 em encapsulamento SMD. A placa possui um segundo controlador, um ATmega16U2 utilizado como conversor USB-serial o que permite sua programação via porta USB, além dos circuitos de controle de clock, alimentação, reset e conexão aos pinos de E/S. Os pinos da placa são descritos com textos impressos na superfície. O esquemático elétrico da placa está ilustrado na figura \ref{fig:esquemaarduinouno} nos anexos.
 
\begin{figure}[h!]
			\centering
			\includegraphics[width=0.6\textwidth]{figures/arduinoUnoFront.jpg}
			\caption{Placa Arduino Uno em detalhes}
			\label{fig:arduinouno}
\end{figure}


\subsection{Especificações Arduino Uno}

A tabela 2.2 mostra um resumo das especificações operacionais da placa Arduino Uno.

\begin{table}[!h]
\caption{Resumo das Especificações - Arduino Uno}
	\begin{tabular}{|r|c|}
		\hline
			Microcontrolador & ATmega328
		\\
		\hline
			Voltagem de Operação (recomendada) & 7-12V
		\\
		\hline
			Voltagem de Operação (limites) & 6-20V
		\\
		\hline
			Pinos de E/S Digitais & 14 (onde 6 permitem saída PWM)
		\\
		\hline
			Pinos de entrada analógicos & 6
		\\
		\hline
			Corrente DC por pino de E/S & 40 mA
		\\
		\hline
			Corrente DC para o pino 3.3V & 50 mA
		\\
		\hline
			Armazenamento em Flash & 32 KB, onde 0.5 KB são usados pelo bootloader
		\\
		\hline
			Memória RAM (SRAM) & 2 KB
		\\
		\hline
			Memória EEPROM & 1 KB
		\\
		\hline
			Frequência de clock & 16 MHz
		\\
\hline
\end{tabular}
\end{table}

\subsection{Alimentação da Placa Arduino Uno}

Um Arduino Uno pode ser alimentado pela conexão USB ou uma fonte externa e a placa faz a seleção automática de fonte de entrada. Uma alimentação com tensão inferior a 7V pode fazer com que o pino de saída de 5V para o microcontrolador forneça uma tensão inferior a descrita causando instabilidade no funcioamento. Por outro lado, se colocada uma tensão de entrada maior que 12V, o regulador de voltagem pode sofrer superaquecimento, danificando a placa e diminuindo sua vida útil.

No desenvolvimento deste projeto foi utilizada, para testes em bancada, uma fonte regulada com saída de 12V e 1850mA de corrente máxima, ilustrada na figura \ref{fig:fontedc}.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.6\textwidth]{figures/fonteAlim.jpg}
			\caption{Fonte de alimentação para testes em bancada}
			\label{fig:fontedc}
\end{figure}

Para a aplicação em automóveis não se faz necessário o uso de regulação de tensão já que os veículos utilizam uma tensão padronizada de 12V, com variações até o máximo de 14V. Apenas é preciso encontrar um ponto de alimentação permanente dentre os cabos do painel e utilizar um cabo com terminal adequado para ligação com a placa Arduino Uno.

Após passar pelos circuitos de alimentação da placa, existem alguns pinos que fornecem alimentação tanto para periféricos quanto para os shields, são estes:

\begin{itemize}
	\item \textbf{Pino 5V:} saída de tensão regulada e estabilizada em 5 volts para alimentar o microcontrolador e outros periféricos como shield, servo-motores de pequeno porte e relés.
	\item \textbf{Pino 3V3:} saída de tensão regulada e estabilizada em 3.3 volts e suporta uma carga máxima de 50 mA. Utilizada principalmente pelo conversor USB-serial e shields que trabalham com comunicação serial TTL.
	\item \textbf{GND:} pino terra, referencial 0 volts para os circuitos.
	\item \textbf{VIN:} mesmo ponto da entrada de alimentação externa, refletindo o mesmo valor da tensão de alimentação do conector jack (barrel).
\end{itemize}

\subsection{Entrada e Saída}

O Arduino Uno possui 14 pinos digitais que podem ser usados como entrada ou saída, operando a 5 volts e suportando 40mA de corrente máxima. Existem funções na biblioteca de programação padrão para facilitar a utlização destes pinos, são elas:

\begin{itemize}
	\item pinMode(): Configura o modo de operação do pino para entrada ou saída.
	\item digitalWrite(): Em modo saída, manipula o estado do pino para HIGH (5V) ou LOW (0V).
	\item digitalRead(): Em modo entrada, lê o estado do pino se está em HIGH ou LOW.
\end{itemize}

Dentre estes pinos, alguns possuem funções especiais como:

\begin{itemize}
	\item Serial: 0 (RX) e 1 (TX). Usados para receber (RX) e transmitir (TX) dados usando padrão serial TTL. São interconectados ao controlador USB.
	\item Interupção externa: 2 e 3. Podem ser configurados para acionar uma função de interrupção em LOW, borda de subida, borda de descida ou mudança no valor, configurados na função attachInterrupt().
	\item PWM: 3,5,6,9,10 e 11. Permitem saída PWM\footnote{Variação de Largura de Pulso: Técnica onde se utiliza um sinal digital para variar o valor da transferência de potência a uma carga de alimentação analógica, simulando, por exemplo uma variação na tensão de alimentação.} de 8 bits, simulando uma saída analógica através da função analogWrite().
	\item SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK). Pinos para comunicação SPI\footnote{Interface de Periféricos Síncrona, padrão para comunicação entre periféricos no modo mestre-escravo}.
	\item LED: 13. Este pino possui um diodo emissor de luz acoplador permitindo testes de entrada/saída com facilidade.
\end{itemize} 

\subsection{Programação}

A programação do microcontrolador ATmega328 do Arduino Uno pode ser feita através da IDE Arduino, ilustrada na figura \ref{fig:ide}. A linguagem de desenvolvimento é C/C++ com recursos exclusivos desenvolvidos com base na linguagem \textit{Wiring}. O microcontrolador vem com um \textit{bootloader} pré-gravado, o que permite o upload de novos códigos com o pressionar de um botão, sem uso de hardware para programação externa, como no caso de gravadores de flash.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.6\textwidth]{figures/ideArduino204.png}
			\caption{Ilustra\c{c}\~{a}o do ambiente de programa\c{c}\~{a}o Arduino}
			\label{fig:ide}
\end{figure}

Sempre que é feita uma gravação de rotina no controlador ocorrerá uma reinicialização do circuito, forçando a sobrescrita de dados na memória RAM. A reinicialização também pode ser feita através do botão reset ou mesmo de um circuito interligado ao pino RESET controlado via software.

\section{Tecnologia GPS}

O termo GPS foi extraído da designação NAVigation System with Time and Ranging Global Positioning System - NAVSTAR GPS, sistema inicialmente voltado às operações miltares, auxiliando na navegação. Em síntese, é um sistema de rádio navegação que fornece as coordenadas bi ou tridimensionais de pontos no terreno, além da velocidade e direção do deslocamento entre pontos.

De acordo com \textcite{gps_iniciantes:2003}, para o funcionamento do GPS, existe uma constelação composta por 24 satélites na orbita terrestre, distribuídos em 6 planos orbitais igualmente espaçados, com 4 satélites em cada plano a uma altitude de aproximadamente 20200 km. Os planos orbitais estão inclinados a $55\,^{\circ}$ em relação ao Equador e o período orbital é de aproximadamente 12 horas. Com esta configuração fica garantido que no mínimo 4 satélites visíveis na superfície da Terra em qualque horário do dia. A figura \ref{fig:conceitogps} ilustra uma idéia conceitual desta configuração.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.4\textwidth]{figures/constelacaoGPS.png}
			\caption{Modelo conceitual da constela\c{c}\~{a}o de sat\'{e}lites GPS}
			\label{fig:conceitogps}
\end{figure}

Além das atividades de navegação, o sistema GPS também auxiliar na realização de levantamentos geodésicos e topográficos, operando de forma ininterrupta, independente das condições meteorológicas mesmo que estas possam afetar na precisão dos dados.

\subsection{Modelo de Posicionamento GPS}

Para identificar a posição de pontos de interesse, o sistema GPS utiliza as coordenadas de seus satélites, que são referenciadas a um sistema geodésico, o mesmo utilzado no receptor GPS para processar os dados recebidos e determinar as coordenadas do ponto referido. A figura \ref{fig:coordenadagps} ilustra este processo, onde o ponto é calculado através das referências de três satélites e estimada quando existe sinal de apenas dois satélites.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.8\textwidth]{figures/triangGPS.jpg}
			\caption{Coordenada de um ponto pela trangulariza\c{c}\~{a}o do sinal de sat\'{e}lites GPS}
			\label{fig:coordenadagps}
\end{figure}

Um sistema GPS é composto por três elementos principais conforme a figura \ref{fig:elementosgps}, são eles:

\begin{itemize}
	\item Estação de Controle: são distribuídas em torno da Terra, próximas da linha do Equador. Dentre suas funções, realizam o monitoramento e controle dos satélites, determinam o tempo GPS, prevêem as efemérides, calculam as correções dos relógios e atualizam as mensagens de navegação dos satélites.
	\item Satélite GPS: propaga as mensagens GPS com suas respectivas coordenadas para que os receptores possam calcular sua posição.
	\item Receptor: usuário do sistema, equipamento que se utiliza dos satélites para obter a posição de determinado ponto.	
\end{itemize}

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.6\textwidth]{figures/elemGPS.png}
			\caption{Elementos do sistema GPS}
			\label{fig:elementosgps}
\end{figure}

\newpage
\section{Arduino GPS Shield Kit}

Para adicionar o suporte a rastreamento via GPS em tempo real ao projeto, um hardware que implemente tal funcionalidade se faz necessário. Neste âmbito, o conceito de shield da plataforma Arduino oferece um gama de componentes que atendem esta necessidade.

Após realizar uma pesquisa de mercado, optou-se pelo uso do GPS Shield Retail Kit da fabricante Sparkfun (\textcite{gpsshield:2013}), que se mostrou financeiramente mais viável, além disso o fabricante disponibiliza todo arcabouço documental, programas de exemplo e esquemáticos de hardware. A figura \ref{fig:kitgps} ilustra os elementos do kit GPS.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.6\textwidth]{figures/6_gps.png}
			\caption{Kit GPS}
			\label{fig:kitgps}
\end{figure}

O kit é composto de dois elementos principais, são eles:

\begin{itemize}
	\item Shield (ou placa base): É uma placa de circuito impresso com laoyut padrão Arduino Uno contendo reguladores de tensão para 3.3 volts, leds indicadores, chave liga/desliga, botão reset e um conector padronizado para diversos modelos de módulos GPS. Esta placa é a peça chave para integração entre o Arduino Uno e o módulo GPS, pois isenta o projetista de realizar qualquer solda ou conexão adicional (salvo casos em que se faz necessário mudar os pinos de comunicação serial), permitindo que este adicione ou remova a funcionalidade GPS ao seu projeto com extrema facilidade. A figura \ref{fig:esquemagpdshield} nos anexos ilustra o esquemático do GPS Shield.

	\item Módulo receptor GPS USGlobalSat EM-406A: Realiza a função de captura das mensagens GPS e cálculo de posicionamento global. Possui todos os componentes integrados, inclusive antena, regulador de voltagem e LED de status. É conectado ao GPS Shield por meio de um cabo de 4 vias. A tabela 2.3 apresenta os dados operacionais do módulo EM-406A.	
\end{itemize}

\begin{table}[!h]
  \caption{Especificações operacionais do módulo GPS EM-406A}
	\centering
	\begin{tabular}{|r|c|}
		\hline
			Canais de recepção & 20
		\\
		\hline
			Sensibilidade & -159 dBm
		\\
		\hline
			Precisão & 10 metros, 5 metros com WAAS
		\\
		\hline
		  Hot Start & 1 segundo
		\\
		\hline
			Warm Start & 38 segundos
		\\
		\hline
			Cold Start & 42 segundos
		\\
		\hline
			Consumo & 70 mA em 4.5-6.5 volts
		\\
		\hline
			Protocolo de Saída & NMEA 0183 e SiRF
		\\
		\hline
			Dimensões & 30mm x 30mm x 10.5mm
		\\
		\hline
		  Peso & 16 gramas
		\\
\hline
\end{tabular}
\end{table}

\newpage
O módulo EM-406A trafega o formato de dados configurado de fábrica em sua resposta ao microcontrolador, este formato é definido no protocolo NMEA 0183 ACII versão 3.01. A mensagem segue a estrutura ilustrada na figura \ref{fig:gprmc} e cada seção dela é descrita na tabela 2.4.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.8\textwidth]{figures/gprmc.png}
			\caption{Mensagem NMEA 0183}
			\label{fig:gprmc}
\end{figure}

\begin{table}[!h]
\caption{Descrições das seções da mensagem NMEA 0183}
\centering
\begin{tabular}{|r|c|c|c|}
     \hline
		{\scriptsize \textbf{Campo}} &	{\scriptsize \textbf{Nome}} & {\scriptsize \textbf{Exemplo}} & {\scriptsize \textbf{Descrição}}\\
		\hline
		1 & {\scriptsize Tempo UTC} & {\scriptsize 060932.448} & {\scriptsize Horário UTC no formato hhmmss.sss}\\
		\hline
		2 & {\scriptsize Status} & {\scriptsize A} & {\scriptsize 'V' = GPS Aquecendo; 'A' = Dados Válidos}\\
		\hline
		3 & {\scriptsize Latitude} & {\scriptsize 2447.0959} & {\scriptsize Latitude no formato ddmm.mmmm}\\
		\hline
		4 & {\scriptsize Indicador N/S} & {\scriptsize N} & {\scriptsize Hemisfério, 'N' = Norte, 'S' = Sul}\\
		\hline
		5 & {\scriptsize Longitude} & {\scriptsize 12100.5204} & {\scriptsize Longitude no formato dddmm.mmmm} \\
		\hline
		6 & {\scriptsize Indicador E/W}  & {\scriptsize E} & {\scriptsize Hemisfério, 'E' = Leste, 'W' = Oeste} \\
		\hline
		7 & {\scriptsize Velocidade}  & {\scriptsize 000.0} & {\scriptsize Velocidade em nós (000.0 ~ 999.9)} \\
		\hline
		8 & {\scriptsize Data UTC} & {\scriptsize 211200} & {\scriptsize Data UTC de uma posição fixa no formato, ddmmyy}\\
		\hline
	\end{tabular}
\end{table}

\section {Comunicação Móvel}

Segundo \textcite{inatel:1998}, "pode-se definir como comunicação móvel aquela onde existe a possibilidade de movimento relativo entre partes ou as partes sistêmicas envolvidas. Como exemplo temos a comunicação entre aeronaves, entre aeronaves e uma base terrena, entre veículos, a telefonia celular, a computação móvel, algumas classes de sistemas de telemetria e outros."

Portanto, devido a característica de mobilidade deste trabalho, onde existe um elemento que se desloca no espaço e ao mesmo tempo necessita trocar dados com um sistema na Internet, este se classifica como um sistema de comunicação móvel. Para suprir as necessidades do projeto, os serviços de telefonia celular, mais especificamente serviços de internet móvel GPRS foram utilizados.

\subsection {Tecnologia GPRS}

O GPRS (General Packet Radio Service) é um serviço que foi criado para possibilitar o tráfego de dados por pacotes na rede GSM, possibilitando que a rede de telefonia celular possa ser ligada a Internet (\textcite{3gpp:2001}).

Na especificação inicial do GSM, a comunicação era realizada através de comutação de circuitos, onde uma conexão entre dois pontos de rede era alocada de forma a estar sempre disponível; a comunicação é feita de forma ininterrupta, uma otimização para chamadas de voz.

Porém a Internet é baseada na comutação de pacotes, e pela natura de circuitos da rede GSM inicial, a velocidade de acesso era muito pequena. Para corrigir esta questão, a tecnologia GPRS foi criada e implementada se comunicando o GSM, trazendo a comutação de pacotes para a rede celular. Neste tipo de comutação, o ponto de origem envia uma informação dentro de um pacote que leva o endereço de destino em seu cabeçalho, o pacote então é transmitido pela rede que é responsável por escolher o melhor caminho até o ponto final.

Na figura \ref{fig:gprscom} é ilustrada a comutação para dados de voz e dados por pacote. O elemento RTPC representa a rede para comunicação de voz, enquanto o elemento IP (Internet Protocol) representa os ponto de integração com a Internet.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.8\textwidth]{figures/gprs.jpg}
			\caption{Comutação de circuito e de pacote nas redes GSM e GPRS}
			\label{fig:gprscom}
\end{figure}

O endereçamento em GPRS é estabelecido em referência a o APN (Access Point Name) da rede. O APN define os serviços de comunicação com a Internet como email e acesso a World Wide Web. Para iniciar uma conexão GPRS, o usuário deve especificar o APN, e opcionalmente um nome de usuário e uma senha, todos estes dados são fornecidos pela operadora. 

\subsection {Arduino Cellular Shield with SM5100B}

Assim como a funcionalidade GPS, existe um kit shield que implementa o acesso ao serviço GPRS das operadoras de celular. Após pesquisa de referências, análise de preços e análise da facilidade de compra, optou-se pelo Cellular Shield com SM5100B do fabicante Sparkfun. O kit é composto pelos seguintes elementos:

\begin{itemize}
	\item Placa de circuito impresso layout padrão Arduino Uno com circuito regulador de tensão, socket para cartão SIM e conector para antena.
	\item Módulo (ou modem) SM5100B da fabricante Spreadtrum, é um módulo miniaturizado, quad-band GSM 850/900/1800/1900 MHz de frequência de rede que implementa as funcionalidades de um celular como SMS, GSM/GPRS, TCP/IP e chamadas de Voz.
	\item Antena quad-band.
\end{itemize}

O módulo se comunica com o microcontrolador através de comandos AT transmitidos por um canal de comunicação serial bidirecional (são utilizados dois pinos digitais do Arduino Uno para montar este canal). A lista de comandos AT está descrita no manual fornecido pelo fabricante, bom como seus parâmetros e respostas. Para funcionamento do kit, é necessário um cartão SIM devidamente habilitado e com plano de dados ativo para as funções GPRS.

 A figura \ref{fig:cellularshield} mostra o kit acoplado a placa Arduino Uno. Devido a necessidade de ganho de sinal, foi utilizada uma antena quad-band de 1.5 dBi similar a mostrada na figura \ref{fig:antenna}.

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.4\textwidth]{figures/gsm.jpg}
			\caption{Ilustra\c{c}\~{a}o do Cellular Shield}
			\label{fig:cellularshield}
\end{figure}

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.4\textwidth]{figures/antena.jpg}
			\caption{Antena quad-band com 1.5 dBi de ganho}
			\label{fig:antenna}
\end{figure}

\section{Controle de carga via Arduino Uno}

Pela especificação da placa Arduino Uno observa-se que seus pinos digitais, quando configurados para saída, suportam apenas 40 mA de corrente máxima em 5 volts, isto é o suficiente para acionamento de leds, buzzers, sensores, ou seja, apenas cargas de pequeno porte.

Dependendo da natureza do projeto, pode ser necessário o acionamento de dispositivos que consumam consumam corrente acima da saída máxima do microcontrolador e/ou operem em tensão diferente da plataforma. Para solucionar esta questão uma das alternativas é necessário utilizar um circuito auxiliar de chaveamento com relê, onde a saída do microncontrolador é utilizada apenas como sinal para acionamento.

A figura \ref{fig:relay} mostra o circuito de acionamento via relê (também conhecido como drive de acionamento), considerando que o relê do esquema possui uma bobina que opera com 5 volts, o funcionamento do circuito pode ser descrito com os seguintes passos: 

\begin{itemize}
	\item Os pontos descritos como RAW são alimentados com a saída de 5 volts do Arduino.
	\item No pino 2 do conector JP2 é ligada uma saída digital do microcontrolador e quando esta é acionada (5V), o transistor 2N3904 (utilizado como chave) permite a passagem de corrente polarizando inversamente o diodo D1.
	\item Com o diodo polarizado inversamente, a diferença de pontencial entre seus terminais se iguala a RAW, atingindo 5 volts.
	\item Nota-se que a bobina do relê está ligada em paralelo com o diodo D1, com isto a mesma é alimentada com a voltagem referente à polarização inversa do diodo, neste exemplo 5 volts. Como o relê opera a esta voltagem, a bobina se magnetiza chaveando os ponto LOAD1 e LOAD2 da figura.
	\item A corrente máxima que este circuito pode controlar depende da capacidade do relê. Valores de 5 a 20 ampéres são comuns.
\end{itemize}

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.8\textwidth]{figures/circRele.png}
			\caption{Circuito de controle de cargas com relê}
			\label{fig:relay}
\end{figure}

Neste projeto foi utilizado uma placa pré-fabricada pelo fornecedor Sparkfun, conforme a figura \ref{fig:placarelay} observa-se que o circuito conta com um pequeno LED sinalizador de estado e conectores para facilitar a instalação. O relê aplicado possui bobina que opera em 5 volts e possui duas malhas de chaveamento utilizáveis:

\begin{itemize}
	\item Malha normalmente aberta (NO) que suporta corrente máxima de 20 ampéres em 240 volts.
	\item Malha normalmente fechada (NC) que suporta corrente máxima de 10 ampéres em 240 volts.
\end{itemize}

\begin{figure}[h!]
			\centering
			\includegraphics[width=0.4\textwidth]{figures/beefCake2.jpg}
			\caption{Placa para controle de cargas por relê}
			\label{fig:placarelay}
\end{figure}

\section{Webservice}

Um webservice é uma arquitetura de comunicação entre dispositivos sobre a Web. Pela definição da W3C é um sistema de software projetado para suportar a interoperabilidade de interação entre máquinas sobre uma rede, possuindo uma interface descrita em um formato processável (especificamente WSDL). Outros sistemas que interagem com um webservice tipicamente usando protocolo HTTP e dados estruturados representados em XML em conjunto com outros tecnologias Web (\textcite{w3c_ws:2004}).

Essencialmente, um Webservice faz com que os recursos de uma aplicação estejam disponíveis sobre a rede de uma forma normalizada, onde cara recurso é identificado por um endereço universal único (URI) acessado pelo protocolo HTTP. Web Services é a tecnologia ideal para comunicação entre sistemas, sendo muito usado em aplicações Business to Business. A comunicação entre os serviços é padronizada possibilitando a independencia de plataforma e de linguagem de programação. Por exemplo, um sistema de reserva de passagens aéreas feito em Java e rodando em um servidor Linux pode acessar, com transparência, um serviço de reserva de hotel feito em .Net rodando em um servidor Microsoft.

O W3C define duas categorias de Webservice:

\begin{itemize}
	\item REST-compliant Webservice: onde o principal propósito do serviço é manipular representações de recursos web em XML (ou similares) usando uma conjunto de operações sem estado.
		\item Webservices arbitrários: onde um webservice expõe um conjunto de operações por meio de uma linguagem de definição de webservices (WSDL).
\end{itemize}

\subsection{REST}

A Transferência de Estado Representacional (Representational State Transfer) ou somente (REST) é uma técnica de engenharia de software para sistemas hipermídia distribuídos como a Web. O termo se originou no ano de 2000, em uma tese de doutorado (PhD) sobre a web escrita por Roy Fielding, um dos principais autores da especificação do protocolo HTTP.

Na aquitetura REST se afirma que a web já fornece a escalabilidade como resultado de uma série de desenhos fundamentais:

\begin{itemize}
	\item Um protocolo cliente/servidor sem estado: cada mensagem HTTP contém toda a informação necessária para compreender uma requisição, como resultado, nem o cliente e nem o servidor necessitam gravar nenhum estado das comunicações. Na prática, muitas aplicações baseadas em HTTP utilizam cookies e outros mecanismos para manter o estado da sessão.
	\item	Um conjunto de operações bem definidas que se aplicam a todos os recursos de informação: HTTP em si define um pequeno conjunto de operações, as mais importantes são POST, GET, PUT e DELETE. Com frequência estas operações são combinadas com operações CRUD para a persistência de dados, onde POST não se encaixa exatamente neste esquema.
	\item	Uma sintaxe universal para identificar os recursos. No sistema REST, cada recurso é unicamente direcionado através da sua URI.
	\item	O uso de hipermídia (links) tanto para a informação da aplicação como para as transições de estado da aplicação: a representação deste estado em um sistema REST são tipicamente HTML ou XML. Como resultado disto, é possível navegar com um recurso REST a muitos outros, simplesmente seguindo ligações sem requerer o uso de registros ou outra infraestrutura adicional.
\end{itemize}

Um conceito importante em REST é a existência de recursos (elementos de informação), que podem ser usados utilizando um identificador global (um Identificador Uniforme de Recurso) para manipular estes recursos, os componentes da rede (clientes e servidores) se comunicam através de uma interface padrão (HTTP) e trocam representações de recursos (XML, JSON ou outro).

\subsection {API Web baseada em REST}

Segundo \textcite{w3c_ws:2004}, uma API implementada utilizando os princípios do HTTP e REST é chamada Web API RESTful, sendo uma coleção de recursos com quatro aspectos principais:

\begin{itemize}
	\item Uma URI base para a API como: http://example.com/resources/
	\item Um tipo de mídia par troca de dados, como XML, JSON ou qualquer outro tipo padronizado que segue o padrão hypertexto.
	\item Um conjunto de operações deve ser suportado usando os métodos HTTP (GET, PUT, POST ou DELETE).
	\ A API deve ser orientada a hypertexto.
\end{itemize}

A tabela 2.5 mostra como um seviço pode ser disponibilizado usando URIs e os métodos HTTP, sendo caracterizado como uma API RESTful.

\begin{table}[!h]
\caption{Web API RESTful}
  \centering
	\begin{tabularx}{\textwidth}{|X|X|X|X|X|}
		\hline
			\textbf{Recurso} & \textbf{GET} & \textbf{PUT} & \textbf{POST} & \textbf{DELETE}
		\\
		\hline
			\textbf{URI de coleções, como} \textit{http://example .com/resources}
			& Lista as URIs e outros detalhes dos membros da coleção.
			& Substitui a coleção inteira com outra coleção.
		  & Cria uma nova entrada na coleção com URI designada automaticamente e retornada pela operação.
			& Deleta a coleção inteira.
		\\
		\hline
			\textbf{URI de elemento, como} \textit{http://example. com/resources /item17}
			& Retorna uma representação do membro da coleção, expressada no formado apropriado (XML, JSON, etc).
			& Substitui o elemento do endereço ou, se não existir, o cria.
		  & Geralmente não usado. Trata o elemento como uma coleção e cria uma nova entrada nele.
			& Deleta o elemento do endereço.
		\\
\hline
\end{tabularx}
\end{table}

\section {Padrões de Projeto}

Um Padrão de Projeto de Software, ou Design Pattern, descreve uma solução geral reutilizável para um problema recorrente no desenvolvimento de sistemas, com paradigma orientado a objetos (\textcite{Gamma:2000}). Não é um código final, é uma descrição ou modelo de como resolver o problema do qual trata, que pode ser usada em muitas situações diferentes. Os Padrões de Projeto normalmente definem as relações e interações entre as classes ou objetos, sem especificar os detalhes das classes ou objetos envolvidos, ou seja, estão num nível de generalidade mais alto.

Os padrões de projeto :

\begin{itemize}
	\item Visam facilitar a reutilização de soluções de design, isto é, soluções na fase de projeto do software.
	\item Estabelecem um vocabulário comum de design, facilitando a comunicação, documentação e aprendizado dos sistemas de software.
\end{itemize}

\subsection{MVC}

Model-view-controller (MVC) é um modelo de arquitetura de software que separa a representação da informação da interação do usuário com ele. O modelo (model) consiste nos dados da aplicação, regras de negócios, lógica e funções. Uma visão (view) pode ser qualquer saída de representação dos dados, como uma tabela ou um diagrama. É possível ter várias visões do mesmo dado, como um gráfico de barras para gerenciamento e uma visão tabular para contadores. O controlador (controller) faz a mediação da entrada, convertendo-a em comandos para o modelo ou visão. As ideias centrais por trás do MVC são a reusabilidade de código e separação de conceitos. (\textcite{mvc_xerox:1978})

Além de dividir a aplicação em três tipos de componentes, o design MVC define as interações entre eles.

\begin{itemize}
	\item Um controller pode enviar comandos para sua visão associada para alterar a apresentação da visão do modelo (por exemplo, percorrendo um documento). Ele também pode enviar comandos para o modelo para atualizar o estado do modelo (por exemplo, editando um documento).
	\item Um model notifica suas visões e controladores associados quando há uma mudança em seu estado. Esta notificação permite que as visões produzam saídas atualizadas e que os controladores alterem o conjunto de comandos disponíveis. Uma implementação passiva do MVC monta estas notificações, devido a aplicação não necessitar delas ou a plataforma de software não suportá-las.
	\item A visão (view) solicita do modelo a informação que ela necessita para gerar uma representação de saída. 
\end{itemize}

\subsection{Singleton}
Singleton é um padrão de projeto onde se garante a existência de apenas uma instância de uma classe, mantendo um ponto global de acesso ao seu objeto. Alguns projetos necessitam que algumas classes tenham apenas uma instância. Por exemplo, em uma aplicação que precisa de uma infraestrutura de log de dados, pode-se implementar uma classe no padrão singleton. Desta forma existe apenas um objeto responsável pelo log em toda a aplicação que é acessível unicamente através da classe singleton.

\subsection{Dao}

DAO (Data Access Object) é um padrão para persistência de dados que permite separar regras de negócio das regras de acesso a banco de dados. Numa aplicação que utilize a arquitetura MVC, todas as funcionalidades de bancos de dados, tais como obter as conexões, mapear objetos Java para tipos de dados SQL ou executar comandos SQL, devem ser feitas por classes de DAO.

\subsection{Factory Method}

Factory Method, é um padrão de projeto que permite as classes delegar para subclasses decidirem ações. O factory method permite delegar a instanciação para as subclasses. O padrão Factory Method contém os seguintes elementos:

\begin{itemize}
	\item Creator — declara o factory method (método de fabricação) que retorna o objeto da classe abstrata. Este elemento também pode definir uma implementação básica que retorna um objeto de uma classe concreta básica;
	\item ConcreteCreator — sobrescreve o factory method e retorna um objeto da classe concreta;
	\item Product — define uma interface para os objetos criados pelo factory method;
	\item ConcreteClass — uma implementação para a interface.
\end{itemize}
